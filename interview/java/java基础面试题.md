# java面试题

## 1、面向对象编程有哪些特征？

- 封装（Encapsulation）：将数据和操作数据的方法封装在一起，隐藏内部实现细节，通过定义公共接口来访问和操作数据。
- 继承（Inheritance）：允许创建基于现有类的新类，并从现有类继承属性和方法，实现代码重用和扩展。
- 多态（Polymorphism）：允许一个对象具有多种形式，即同一个方法可以在不同对象上产生不同的行为。
- 抽象（Abstraction）：通过定义抽象类或接口来提供通用的模板和规范，隐藏实现细节，使得代码更加灵活和可扩展。

## 2、JDK 与 JRE 的区别是什么？

- JDK是Java开发工具包，它包含了完整的Java开发环境，包括编译器（javac）、调试器（jdb）和其他用于开发和调试Java程序的工具。JDK适用于开发人员进行Java应用程序的开发工作。
- JRE是Java运行时环境，它包含了执行Java程序所需的运行时库和Java虚拟机（JVM）。JRE适用于只需要运行Java程序而不进行开发的用户。

## 3、Java 有哪几种基本数据类型？

- 整数类型：byte、short、int、long
- 浮点数类型：float、double
- 布尔类型：boolean
- 字符类型：char

## 4、== 和 equals 比较有什么区别？

- "==" 用于比较两个变量的值是否相等，对于基本数据类型比较的是值，对于引用类型比较的是内存地址。
- "equals()" 是Object类的方法，在继承关系中，子类可以重写该方法用于比较对象的内容是否相等。通常情况下需要自定义类重写"equals()"方法，使其比较对象的值而不是内存地址（string）。

## 5、public,private,protected,默认的区别？

- public：公共访问级别，对所有类可见。
- private：私有访问级别，只对当前类可见，其他类无法访问。
- protected：受保护访问级别，对同一个包内的类和所有子类可见。
- 默认（没有修饰符）：在同一个包内可见，对子类和其他包的类不可见。

## 6、this 和 super 有什么区别？

- "this" 是一个引用，表示当前对象实例自身。它可以用于引用当前对象的成员变量、成员方法或者调用当前对象的构造方法。
- "super" 也是一个引用，表示父类的对象。它可以用于引用父类的成员变量、成员方法或者调用父类的构造方法。

## 7、short s1 = 1; s1 += 1;有错吗？

"short s1 = 1; s1 += 1;" 没有错误。这是由于 "+=" 运算符会进行自动类型转换，将结果赋值给左边的操作数。在这种情况下，s1 是一个 short 类型的变量，进行 "+=" 运算后自动转换为 int 类型并且最终结果可以被正确赋值给 s1。

## 8、short s1 = 1; s1 = s1 + 1;有错吗？

"short s1 = 1; s1 = s1 + 1;" 有错误。这是因为 "+=" 运算符没有进行自动类型转换，而是通过将右边的操作数（s1 + 1）转换为 int 类型来执行加法操作，然后尝试将 int 类型赋值给 short 类型的变量 s1 时发生错误，需要进行强制类型转换才能编译通过。

## 9、float n = 1.8 有错吗？

"float n = 1.8" 有错误。这是因为浮点数直接量默认是 double 类型，将 double 类型的值赋给 float 类型的变量需要进行强制类型转换。正确的写法应为 "float n = 1.8f;"，在数字后面添加 'f' 或 'F' 表示浮点数直接量属于 float 类型。

## 10、i++ 和 ++i 的区别？

\- "i++" 是后缀递增运算符，它先使用变量的值，然后再将变量递增1。 - "++i" 是前缀递增运算符，它先将变量递增1，然后再使用变量的值。

## 11、while 和 do while 有啥区别？

- while 循环：先判断条件是否满足，如果满足则执行循环体，然后再次判断条件，如果条件仍然满足则继续执行循环体，直到条件不满足时跳出循环。
- do-while 循环：先执行循环体，然后再判断条件是否满足，如果满足则继续执行循环体，直到条件不满足时跳出循环。至少会执行一次循环体。

## 12、如何跳出 Java 中的循环？

- 使用 break 关键字可以立即跳出当前循环，结束循环的执行。
- 使用 continue 关键字可以终止当前迭代，进入下一轮循环。

## 13、如何跳出 Java 中间的多层嵌套循环？

- 使用带有标签的 break 语句可以跳出指定标签的循环，从而跳出多层嵌套循环。

## 14、& 和 && 的区别？

- & 是按位与运算符，在逻辑表达式中表示逻辑与。无论左边的表达式结果是 true 还是 false，都会执行右边的表达式。
- && 是短路与运算符，在逻辑表达式中只有当左边的表达式结果为 true 时，才会执行并判断右边的表达式。

## 15、2 * 8 最有效率的计算方法是什么？

- 2 * 8 的最有效率计算方法是直接使用乘法运算符，即 2 * 8。

## 16、数组有没有 length 方法？String 呢？

- 数组有 length 属性来获取数组的长度，例如：int[] array = {1, 2, 3}; int length = array.length;
- String 类也有 length() 方法来获取字符串的长度，例如：String str = "Hello"; int length = str.length()

## 17、怎么理解价值传递和引用传递？

- 值传递（传值）：当将一个变量传递给一个方法时，实际传递的是变量的副本，对副本的修改不会影响原始变量。
- 引用传递（传引用）：当将一个对象（非基本数据类型）传递给一个方法时，实际传递的是对象的引用（地址），对引用指向的对象的修改会影响原始对象。

## 18、Java 到底是值传递还是引用传递？

- Java 是值传递。对于基本数据类型，直接传递的是值本身；对于引用数据类型，传递的是引用的副本，因此在方法内部修改引用的指向不会影响原始引用的指向，但是可以通过引用修改对象的内容。

## 19、一个 ".java" 源文件的类型有什么限制？

- 一个 ".java" 源文件可以包含一个公共类和多个非公共类，但只能有一个公共类，并且公共类的名称必须与文件名相同。

## 20、Java 中的注释有哪些写法？

- 单行注释：以 "//" 开始，可用于注释一行或部分行的代码。
- 多行注释：以 "/*" 开始，以 "*/" 结束，可用于注释多行代码。
- 文档注释：以 "/**" 开始，以 "*/" 结束，用于生成 API 文档。

## 21、static 关键字有什么用？

- static 关键字可以修饰类的成员变量和方法，以及内部类。
- 用于修饰成员变量时，表示该变量为静态变量，属于类而不是实例，所有实例共享同一份静态变量的内存空间。
- 用于修饰方法时，表示该方法为静态方法，可以通过类名直接调用，无需创建对象。
- 用于修饰内部类时，表示内部类为静态内部类，与外部类的实例无关，可以直接访问外部类的静态成员。

## 22、static 变量和普通变量的区别？

- static 变量属于类，普通变量属于对象。static 变量在内存中只有一份拷贝，被所有实例共享；普通变量在每个对象中都有一份拷贝，互相独立。
- static 变量可以在没有对象实例的情况下访问和修改；普通变量需要通过对象实例才能访问和修改。
- static 变量在类加载时初始化，且一直存在于内存中，直到程序结束；普通变量在对象创建时初始化，随着对象的销毁而销毁。

## 23、static 可以修饰局部变量么？

static 不可以修饰局部变量：

- static 关键字用于修饰成员变量和方法，属于类的一部分。而局部变量是在方法内部定义的变量，生命周期只在方法的执行过程中，不存在于类的范围之内。

## 24、final 关键字有哪些用法？

final 关键字的用法：

- final 可以修饰类、方法和变量。
- 修饰类时，表示该类不能被继承。
- 修饰方法时，表示该方法不能被子类重写。
- 修饰变量时，表示该变量为常量，一旦赋值后不可修改。

## 25、final、finally、finalize 有什么区别？

final、finally、finalize 的区别：

- final：用于修饰类、方法和变量，分别表示不可继承、不可重写和不可修改的含义。
- finally：用于异常处理语句的结构中，无论是否发生异常，finally 块中的代码都会被执行。
- finalize：是 Object 类中的一个方法，用于垃圾回收器清理对象前的操作。当对象被垃圾回收时，finalize 方法会被调用。

## 26、void 和 Void 有什么区别？

- void 是 Java 中的关键字，表示无返回值的方法或表明无类型（空）。
- Void 是一个包装类，用于表示一个不可实例化的 Java 类型，主要用于泛型和反射。

## 27、为什么 byte 取值范围为 -128～127？

- byte 是有符号的整数类型，使用一个字节（8位）来表示。其中最高位是符号位，0 表示正数，1 表示负数。剩下的 7 位表示数值的大小。
- -128 到 127 是由于一个字节的二进制补码范围为 -2^7 (-128) 到 2^7-1 (127)。超过这个范围的数值无法用一个字节来表示，会溢出。

## 28、char 类型可以存储中文汉字吗？

- char 类型在 Java 中占用两个字节（16位），用于表示 Unicode 字符集中的字符。Unicode 包括了全球各种语言文字的字符，因此 char 类型可以存储中文汉字。

## 29、重载和重写有什么区别？

- 重载是指在同一个类中，方法名相同但参数类型、个数、顺序不同的多个方法。重载通过改变方法的参数列表来实现同名方法的多态性。
- 重写是指子类对父类中同名方法的重新实现。重写要求方法名、参数类型、返回类型都相同，可以扩大访问权限，但不能缩小访问权限。

## 30、构造器可以被重写和重载吗？

- 构造器（构造方法）是一种特殊的方法，用于创建对象时进行初始化。
- 构造器可以被重载，即在同一个类中可以定义多个构造器，通过参数的不同来区分。
- 构造器不能被重写，因为构造器的名字与类名相同，且没有返回值，所以没有必要进行重写。

## 31、main 方法可以被重写和重载吗？

- main 方法是程序的入口，是 JVM 调用的特殊方法。
- main 方法的签名是固定的，必须是 public static void main(String[] args)。
- 重写是指子类对父类中同名方法的重新实现，但由于 main 方法是静态方法，不存在继承关系，所以不能被重写。
- 重载是指在同一个类中，方法名相同但参数类型、个数、顺序不同的多个方法。但由于 JVM 在启动时通过固定的方法签名调用 main 方法，因此也不能被重载。

## 32、私有方法能被重载或者重写吗？

私有方法不能被重载或者重写：

- 重载和重写都是基于继承或接口实现的概念，而私有方法无法被继承或接口实现。
- 私有方法是指只能在定义该方法的类中访问的方法，无法被其他类继承或重写。

## 33、Java 中的断言（assert）是什么？

- 断言是一种在代码中插入的检查机制，用于验证程序运行时的某个条件是否满足。
- 使用 assert 关键字加上语句作为条件，如果条件为 false，就会抛出 AssertionError 异常。
- 断言主要用于开发调试阶段，可以在代码中临时插入，方便进行测试和调试。

## 34、Java 异常有哪些分类？

- 检查时异常（Checked Exception）：必须显式处理或在方法签名中声明抛出，否则编译器会报错。
- 运行时异常（Runtime Exception）：通常是由程序错误引起的，不需要显式处理或声明抛出。
- 错误（Error）：指系统级的错误或资源耗尽等严重情况，一般无法通过代码处理。

## 35、Error 和 Exception 有什么区别？

- Error 是指系统级的错误或资源耗尽等严重情况，一般无法通过代码处理。例如 OutOfMemoryError（内存溢出）、StackOverflowError（栈溢出）等。
- Exception 是可处理的异常，分为检查时异常和运行时异常，需要通过代码进行处理。

## 36、Java 中常见的异常有哪些？

- NullPointerException（空指针异常）：访问 null 对象的属性或调用 null 对象的方法。
- IllegalArgumentException（非法参数异常）：传递给方法的参数不合法。
- IndexOutOfBoundsException（索引越界异常）：访问数组、集合等数据结构时，索引超出范围。
- ClassCastException（类转换异常）：类型转换失败。
- IOException（输入输出异常）：读写文件、网络操作等出现错误时抛出的异常。

## 37、Java 中常见的运行时异常有哪些？

- NullPointerException（空指针异常）
- ArrayIndexOutOfBoundsException（数组索引越界异常）
- ArithmeticException（算术运算异常）
- ClassCastException（类转换异常）
- IllegalArgumentException（非法参数异常）
- IllegalStateException（状态异常）
- UnsupportedOperationException（不支持的操作异常）

## 38、运行时异常与受检查时异常有什么区别？

- 运行时异常是指在程序运行过程中可能抛出的异常，编译器不会强制要求进行处理或声明抛出。
- 受检查时异常是指在程序运行过程中可能抛出的异常，编译器会强制要求进行处理或在方法签名中声明抛出。

## 39、什么时候会发生空指针异常？

- 当对一个 null 对象调用其方法或访问其属性时，会发生空指针异常。
- 例如：String str = null; str.length();

## 40、你知道有哪些避免空指针的方法？

- 避免使用未经初始化或赋值的变量。
- 在使用对象之前，先判断对象是否为 null。
- 使用条件判断语句或三目运算符处理可能为空的情况。
- 使用 Java 8 引入的 Optional 类来封装可能为空的对象。
- 编写防御性代码，及时检查和处理可能引发空指针异常的情况。

## 41、throw 和 throws 的区别？

throw 和 throws 的区别：

- throw 是用于手动抛出异常的关键字，它可以在代码中主动抛出异常对象。
- throws 是用于方法声明中的关键字，表示该方法可能抛出异常，并将异常的处理责任交给调用者。

## 42、try-catch-finally 中哪个部分可以省略？

try-catch-finally 中哪个部分可以省略：

- catch 和 finally 都可以省略，但 try 块是必须存在的。
- catch 可以省略的情况是，try 块中没有抛出异常，或者异常被 throw 抛出到上层处理。
- finally 可以省略的情况是，不需要对资源进行释放或清理操作。

## 43、try 里面 return，finally还会执行吗？

try 里面 return，finally 还会执行吗：

- finally 块一定会执行，不论是否在 try 块中含有 return 语句。
- 如果在 try 块中遇到 return 语句，会先执行 finally 块中的代码，然后再执行 return 语句。

## 44、int 和 Integer 有什么区别？

- int 是 Java 的基本数据类型，用于表示整数，占用固定的内存空间。
- Integer 是 int 类型的包装类，它提供了一些额外的功能，如转换成字符串、比较大小等。Integer 对象是引用类型，占用较多的内存空间。

## 45、什么是包装类型？有什么用？

包装类型是指为了使基本数据类型具备对象的性质而产生的类，每个基本数据类型都有对应的包装类型。包装类型的作用包括：

- 能够在基本数据类型和引用类型之间进行转换。
- 可以使用包装类型提供的方法进行数据处理和操作。
- 在泛型、集合类等需要对象的场景中，可以使用包装类型作为元素或参数。

## 46、什么是自动装厢、拆厢？

自动装箱（Autoboxing）和拆箱（Unboxing）是 Java 中基本数据类型和对应包装类之间自动转换的过程：

- 自动装箱是指将基本数据类型自动转换为相应的包装类对象，使用包装类的构造方法或静态方法完成。
- 自动拆箱是指将包装类对象自动转换为相应的基本数据类型，可以直接赋值给基本数据类型变量或进行算术运算。

## 47、你怎么理解 Java 中的强制类型转换？

强制类型转换是指将一个数据类型强制转换为另一个数据类型，需要使用强制类型转换运算符：

- 强制类型转换可能会导致精度丢失或溢出，因此需要谨慎使用。
- 例如，将一个较大的整数类型强制转换为较小的整数类型时，可能会导致数据溢出。

## 48、你怎么理解 Java 中的自动类型转换？

自动类型转换是指在一定条件下，Java 编译器会自动将低精度类型的值转换为高精度类型的值，不需要显式进行类型转换：

- 自动类型转换是向上转型，从较小的数据类型到较大的数据类型。
- 例如，将一个 int 类型的值赋给 long 类型的变量时，会发生自动类型转换。

## 49、你怎么理解 Java 中的类型提升？

类型提升是指在进行运算时，低精度的数据类型会自动提升为高精度的数据类型，可以保证数据不丢失：

- 类型提升也是一种自动类型转换。
- 例如，在整数运算中，如果有一个操作数是 long 类型，那么其他操作数会被自动提升为 long 类型，以执行更准确的计算。

## 50、switch 是否能用在 long 上？

switch 不能直接用于 long 类型，因为 switch 只支持整数类型（int）和字符类型（char）的数据：

- 在 Java 7 及之前的版本，switch 只支持 byte、short、int 和 char 四种整数类型。
- 在 Java 8 中，switch 支持使用枚举类型和字符串类型。
- 如果需要在 switch 中使用 long 类型，可以通过将 long 转换为 int 或使用 if-else 来实现。

## 51、switch 是否能用在 String 上？

## 52、switch case 支持哪几种数据类型？

## 53、String 属于基础的数据类型吗？

不属于，属于引用类型

## 54、String 类似的常用方法都有哪些？

## 55、String 的底层实现是怎样的？

字符数组

## 56、String 是可变的吗？为什么？

## 57、String 类可以被继承吗？

## 58、String 真的是不可变的吗？

## 59、String 字符串如何进行反转？

## 60、String 字符串如何实现编码转换？

## 61、String 有没有长度限制？是多少？

## 62、为什么不能用 + 拼接字符串？

## 63、StringBuffer 和 StringBuilder 的区别？

## 64、StringJoiner 有什么用？

## 65、Java 所有的祖先类是哪个？

## 66、Object 类有哪些常用的方法？

## 67、普通类和抽象类有什么区别？

## 68、静态内部类和普通内部类有什么区别？

## 69、静态方法可以直接调用非静态方法吗？

## 70、静态变量和实例变量有什么区别？

## 71、内部类可以访问其外部类的成员吗？

## 72、接口和抽象类有什么区别？

## 73、接口是否可以继承接口？

## 74、接口里面可以写方法实现吗？

## 75、抽象类必须要有抽象方法吗？

## 76、抽象类能使用 final 修饰吗？

## 77、抽象类是否可以继承具体类？

## 78、抽象类是否可以实现接口？

## 79、怎么查看一个 Java 类的字节码？

## 80、Java 中的 UUID 是什么?

## 81、Java 类初始化顺序是怎样的？

## 82、为什么成员变量命名不建议用 isXXX？

## 83、hashCode 有什么用？

## 84、hashCode 和 identityHashCode 的区别？

## 85、什么是 hash 冲突？

## 86、equals 和 hashCode 的区别和联系？

## 87、两个对象 equals 相等， hashCode 也相等么？

## 88、两个对象 hashCode 相等，equals 也相等么？

## 89、为什么重写 equals 就要重写 hashCode 方法？

## 90、Java 常用的元注解有哪些？

## 91、Java 泛型中的 T、R、K、V、E 分别指什么？

## 92、Java 金额计算怎么避免精通丢失？

## 93、Java 语法糖是什么意思？

## 94、transient 关键字有什么用？

## 95、如何实现对象克隆？

## 96、对象克隆浅拷贝和深拷贝的区别？

## 97、Java 反射机制有什么用？

## 98、Java 反射机制的优缺点？

## 99、Java 反射机制 Class 类有哪些常用方法？

## 100、Java 反射可以访问私有方法吗？

## 101、Java 反射可以访问私有变量吗？

## 102、Class.forName 和 ClassLoader 的区别？

## 103、什么是宏变量和宏替换？

## 104、什么是逃逸分析？

## 105、什么是伪共享？有什么解决方案？

## 106、Java 有没有 goto 关键字？

## 107、Java 中有没有指针的概念？

## 108、Java 中的 classpath 环境变量作用？

## 109、Math.round(1.5) 等于多少？

## 110、Math.round(-1.5) 等于多少？

## 111、Java 8 都新增了哪些新特性？

## 112、Java 8 中的 Lambda 表达式有啥用？

## 113、Java 8 中的 Optional 类有什么用？

## 114、Java 8 中的 Stream 有啥用？

## 115、Java 8 中的@Repeatable 注解有什么用？

## 116、Java 8 中的方法引用是指什么？

## 117、Java 8 中的函数式编程怎么用？

## 118、怎么创建一个 Stream 流？

## 119、Oracle JDK 和 OpenJDK 有啥区别？

