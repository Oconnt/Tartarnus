# http基础面试题

## 1、get和post请求的区别

1. 参数传递位置：GET请求将参数附加在URL的查询字符串中，以`?`开头，多个参数之间使用`&`分隔。而POST请求将参数包含在请求的消息体中。
2. 请求长度限制：GET请求对参数的长度有限制，由于将参数放在URL中，URL长度受到浏览器和服务器的限制，通常在2048个字符左右。而POST请求对参数的长度理论上没有限制，因为参数包含在消息体中。
3. 安全性：GET请求的参数是明文显示在URL中，因此不适合传递敏感信息，比如密码等。POST请求的参数被包含在消息体中，相对安全。
4. 数据类型：GET请求一般用于获取数据，不应该对服务器状态进行修改。而POST请求可以用于修改服务器的状态，比如提交表单、上传文件等。
5. 缓存：GET请求可以被浏览器缓存，且可以被收藏为书签。而POST请求不能被缓存和收藏，每次请求都需要重新发送。
6. 可见性：GET请求的参数会显示在浏览器的地址栏中，用户可以看到。而POST请求的参数在请求过程中是不可见的。

## 2、HTTP 和 HTTPS 的区别？

1. 安全性：HTTP是明文传输数据的协议，数据在传输过程中不加密，容易被窃听和篡改。而HTTPS通过使用SSL/TLS协议进行加密，确保数据在传输过程中的安全性和完整性。
2. 默认端口：HTTP使用默认端口80进行通信，而HTTPS使用默认端口443进行通信。
3. 连接方式：HTTP使用无状态的连接方式，即每次请求与响应之间没有持久的连接。而HTTPS可以使用持久连接，提供更好的性能。
4. 证书：HTTPS使用证书来验证服务器的身份，并建立安全连接。服务器需要获得可信的数字证书，而HTTP没有类似的证书验证机制。
5. URL前缀：HTTP的URL以"http://"开头，而HTTPS的URL以"https://"开头。
6. 加密算法：HTTPS使用SSL/TLS协议进行数据加密，支持多种加密算法，如RSA、AES等。而HTTP没有加密处理。
7. 性能：由于HTTPS需要进行加密和解密操作，相比HTTP而言，会带来一定的性能开销。HTTPS比起HTTP会消耗更多的计算资源和网络带宽。

## 3、三次握手和四次挥手

1. **三次握手：** 

   a. 第一步：客户端发送一个SYN标志的TCP请求包（SYN包）给服务器，表示请求建立连接，并随机选择一个初始序列号。 

   b. 第二步：服务器接收到客户端的SYN包后，回复一个ACK标志的TCP响应包（ACK包），表示同意建立连接，同时也发送一个SYN标志的包（SYN-ACK包）给客户端，确认请求，并选择自己的初始序列号。 

   c. 第三步：客户端接收到服务器的SYN-ACK包后，发送一个ACK标志的包给服务器，表示确认连接的建立。服务器收到这个ACK包后，完成连接的建立。

2. **四次挥手：** 

   a. 第一步：客户端发送一个FIN标志的TCP包（FIN包）给服务器，表示要关闭连接。 

   b. 第二步：服务器收到客户端的FIN包后，发送一个ACK标志的包给客户端，表示已经收到关闭请求。 

   c. 第三步：服务器发送一个FIN标志的包给客户端，表示要关闭连接。 

   d. 第四步：客户端收到服务器的FIN包后，发送一个ACK标志的包给服务器，表示确认收到关闭请求。服务器收到这个ACK包后，完成连接的关闭。

## 4、TCP与UDP区别

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是网络通信中两种常用的传输协议，它们之间的主要区别如下：

1. 连接性：TCP是一种面向连接的协议，通过三次握手建立可靠的连接，确保数据传输的可靠性。UDP是无连接的协议，不需要事先建立连接，发送数据时也不会收到对方是否接收成功的确认。
2. 可靠性：TCP提供可靠的数据传输，通过序号、确认和重传机制来保证数据的完整性和正确性。UDP不提供可靠性保证，发送的数据包可能丢失、重复或者乱序。
3. 传输效率：由于TCP保证了可靠性，所以在传输过程中会有较多的额外开销，如序号管理、确认机制、重传等，因此在传输效率上相对较低。而UDP没有这些额外开销，传输效率较高。
4. 数据包大小：TCP可以处理任意大小的数据，将较大的数据拆分成适合网络传输的小数据段进行传输。UDP每个数据包的大小限制在64KB内。
5. 顺序保证：TCP能够保证数据包按照发送的顺序进行接收和传送，而UDP不能保证数据包的顺序性。
6. 适用场景：TCP适用于对数据可靠性要求较高的应用，如文件传输、电子邮件等。UDP适用于实时性要求较高的应用，如实时视频、音频通信等。

**TCP提供可靠的连接和数据传输，适用于对数据可靠性要求较高的应用场景；UDP是一种简单、快速的传输协议，适用于实时性要求较高的应用场景。选择使用TCP还是UDP需要根据具体的应用需求来决定。**



## 5、TCP协议怎么保证传输可靠性，如果收到了重复数据怎么办？

TCP（传输控制协议）通过以下机制来保证传输的可靠性：

1. 序列号和确认应答：每个 TCP 数据包都有一个唯一的序列号，用于指示数据在传输中的顺序。接收方会发送确认应答（ACK）来确认已经成功接收到的数据，并告知发送方下一次期望接收的数据的序列号。
2. 超时重传：发送方会设置一个定时器，在发送数据后等待一段时间，如果在超时时间内未收到对应的 ACK 确认，发送方会重新发送该数据。
3. 滑动窗口：TCP 使用滑动窗口机制来控制发送方发送数据的速率。接收方会告知发送方它的接收窗口大小，发送方根据接收窗口的大小进行发送，确保不会发送过多的数据，避免接收方无法处理。
4. 丢失数据的检测和重传：如果接收方发现收到的数据包有缺失，它会发送一个特殊的 ACK，告知发送方需要重传缺失的数据。

当收到重复的数据时，TCP 会采取以下操作：

1. 接收方会检测到接收到了重复的数据，但不会将其交给上层应用程序。它会正常发送一个 ACK 确认，通知发送方已经接收到了这些重复数据。
2. 发送方在收到 ACK 确认后，发现这个 ACK 确认的序列号大于当前未被确认的最大序列号，说明之前发送的数据包中有丢失的部分。发送方会根据收到的 ACK 确认来进行重传，确保丢失的数据能够被接收方正确接收。

通过以上的机制，TCP 可以有效地保证传输的可靠性，并能够应对重复数据的情况。

## 6、浏览器输入网址以后都做了哪些动作？

1. URL 解析：浏览器会解析输入的网址（URL），提取出协议（如HTTP、HTTPS）、主机名（域名）、端口号、路径、查询参数等信息。
2. DNS 解析：浏览器将主机名转换为对应的 IP 地址。它会向本地 DNS 缓存查询，如果没有缓存则会发起 DNS 查询请求到 DNS 服务器，并获取到对应的 IP 地址。
3. 建立网络连接：浏览器通过 TCP/IP 协议与目标服务器建立网络连接。它会使用获取到的 IP 地址和端口号建立 socket 连接。
4. 发起 HTTP 请求：浏览器向目标服务器发送 HTTP 请求。请求中包含方法（GET、POST等）、路径、头部信息、请求体（例如表单数据或请求的内容）等。
5. 接收响应：目标服务器收到请求后，会根据请求进行处理，并生成相应的 HTTP 响应。服务器将响应报文发送回浏览器。
6. 处理响应：浏览器接收到服务器的响应后，会根据响应的状态码（如200、404等）来判断请求是否成功。同时，浏览器会解析响应报文中的头部信息和响应体，以获取所需的数据。

## **7、如何实现tcp的流量控制？**

TCP（传输控制协议）使用了一种称为滑动窗口的机制来实现流量控制。滑动窗口的目的是确保发送方不会发送过多的数据，以使接收方能够处理和接收这些数据。

以下是 TCP 流量控制的基本原理：

1. 窗口大小（Window Size）：TCP 在连接建立时使用窗口大小进行初始化，表示接收方在没有确认之前可以接收的最大数据量。窗口大小是一个动态的值，接收方可以通过 TCP 协议中的窗口更新信息告知发送方窗口大小的变化。
2. 滑动窗口机制：发送方根据接收方返回的窗口大小信息来决定发送的数据量。发送方发送的数据不能超过接收方的窗口大小，以确保接收方有足够的缓冲区来接收和处理数据。
3. 窗口滑动：接收方将已成功接收并处理的数据确认返回给发送方。发送方根据接收到的确认信息，移动发送窗口的起始位置，允许发送更多的数据。这样，发送方可以根据接收方的处理能力进行调整，避免发送过多的数据导致接收方溢出或拥塞。

# mysql基础面试题

## 1、Mysql中事务的四大特性：

 原子性（Atomicity）、一致性（Consistent）、隔离性（Isalotion）、持久性(Durable)，简称为ACID。
 **原子性：**事务的原子性操作，对数据的操作要么全部成功，要么全部失败，实现事务的原子性是基于事务的Redo/Undoh机制。
 **一致性：**执行事务的前后状态一致，理解为数据的一致性。
 **隔离性：**事务之间互相隔离，不受影响，与事务的隔离级别有关。
 **持久性：**事务提交之后，事务的状态会被持久化到数据库中。



**实现：**

```
原子性：通过undolog实现。
持久性：通过redolog实现。
隔离性：通过加锁（当前读）&MVCC（快照读）实现。
一致性：通过undolog、redolog、隔离性共同实现。
```



## 2、Redo/Undo机制：

 Redo log: 可以用来恢复未写入数据库中但是事务已经成功提交的的数据。(某一时刻，我事务已经提交了，刚要写到数据库，结果数据库挂了，这时候数据库重启的时候就会通过Redo log来进行数据的恢复)
 Undo log: 用来记录数据被修改前的值，主要用于事务执行失败后进行回滚。



## 3、事务的隔离级别：

 1.**读未提交（READ UNCOMMITTED）**、产生脏读问题。
 2**.读提交 （READ COMMITTED）**、解决了脏读的问题，出现了不可重复读，即在一个事务任意时刻读到的数据可能不一样，可能会受到其它事务对数据修改提交后的影响，一般是对于update的操作。
 3.**可重复读 （REPEATABLE READ）**、解决了之前不可重复读和脏读的问题，但是由带来了幻读的问题，幻读一般是针对insert操作。
 4.**串行化 （SERIALIZABLE）**



| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 第一类更新丢失 | 第二类更新丢失 |
| -------- | ---- | ---------- | ---- | -------------- | -------------- |
| 读未提交 | √    | √          | √    | ×              | √              |
| 读提交   | ×    | √          | √    | ×              | √              |
| 可重复读 | ×    | ×          | √    | ×              | ×              |
| 串行化   | ×    | ×          | ×    | ×              | ×              |

## **4、脏读、幻读、不可重复读问题如何定义**

**1、脏读问题：** 开启一个事物A对数据进行了修改，而此次修改并没有提交到数据库中，这时另一个事务B也访问了这个数据，当且读到事务A修改后未提交的数据，叫做脏读。
 **2、不可重复读问题：** 指在一个事务内，多次读同一数据，结果不一样。事务A开启了事务读取了一条数据，未提交事务，这时候，事务B也开启了事务，针对一条数据。
 并修改了这条数据，然后提交了事务，事务A再次读取这条数据的时候，产生了不一致的结果。
**3、幻读问题：** 是指当事务不是独立执行时发生的一种现象，例如第一个事务查询某个范围的数据行。同时，第二个事务新增、修改、删除这个范围的数据，导致结果不一致这个表中的数据，针对范围数据。
 这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

## 5、脏读、幻读、不可重复读问题如何解决

脏读、幻读和不可重复读是数据库中的并发访问问题，可以通过以下方式进行解决：

1. **脏读（Dirty Read）**： 脏读是指一个事务读取了另一个事务尚未提交的数据，而后者可能会回滚，导致前者读取到了无效的数据。为了解决脏读问题，可以使用事务的隔离级别来控制，将隔离级别设置为“读已提交”（Read Committed）或更高级别，确保一个事务只能读取到已经提交的数据。
2. **幻读（Phantom Read）**： 幻读是指一个事务在两次查询之间，另一个事务插入了符合前一次查询条件的新数据，导致前一次查询得到的结果集发生了变化。要解决幻读问题，可以采用两种方法：一种是使用锁机制，如行级锁或表级锁，保证在一个事务执行期间，其他事务不能插入符合条件的新数据；另一种是使用数据库的多版本并发控制（Multi-Version Concurrency Control，MVCC），即通过版本号或时间戳来控制事务的隔离，读取到的数据是一致的。
3. **不可重复读（Non-Repeatable Read）**： 不可重复读是指一个事务多次读取同一行数据，但在两次读取之间，另一个事务修改了该行数据，导致第一次读取和第二次读取的结果不一致。为了解决不可重复读问题，可以使用事务的隔离级别来控制，将隔离级别设置为“可重复读”（Repeatable Read）或更高级别，确保在一个事务中多次读取同一行数据时，结果保持一致。

另外，为了更好地解决并发访问问题，还可以采用以下策略：

- 使用悲观锁或乐观锁来控制并发操作，保证数据的一致性。
- 合理设计数据表和索引，减少数据访问冲突的可能性。
- 良好的业务逻辑设计，使得事务执行时间尽量短，减少并发访问的冲突机会。
- 合理配置数据库连接池和线程池，控制并发数量，避免资源竞争和阻塞。

综上所述，通过设置事务隔离级别、使用锁机制或MVCC，并结合合理的数据库设计和系统配置，可以有效解决脏读、幻读和不可重复读等并发访问问题。

## 6、Mysql的锁机制

 InnoDB：只有行级别的锁和表级别的锁;

粒度划分：行锁、表锁

用法划分：乐观锁、悲观锁

类型/基本模式：排他锁、共享锁、意向锁、自增锁

算法：间隙锁、记录锁、插入意向锁、临键锁

## 7、乐观锁与悲观锁

**悲观锁：**

每次获取到数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁
期间对该数据进行读写的其他线程都会进行等待 
适合写入操作比较频繁的场景

**乐观锁：**

每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁。
但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新；如果没有被修改，则进行数据更新
适合读取操作比较频繁的场景

## 8、怎么对mysql进行优化？

MySQL 常用30种SQL查询语句优化方法：

1.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

2.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。可以在num上设置默认值0，确保表中num列没有null值。

4.尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用union all。

5.like匹配查询：%放前面会导致索引失效

6.in 和 not in 也要慎用，否则会导致全表扫描，对于连续的数值，能用 between 就不要用 in 了

7.如果在 where 子句中使用参数，也会导致全表扫描。 select id from t where num=@num

可以改为强制查询使用索引，select id from t with(index(索引名)) where num=@num

8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，

并且应尽可能的让字段顺序与索引顺序相一致。

11.很多时候用 exists 代替 in 是一个好的选择：

12.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，

视具体情况而定。一个表的索引数较好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

13.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

14.避免频繁创建和删除临时表，以减少系统表资源的消耗。

**MySQL优化常用方法：**

**1、选取最适用的字段属性**
表中字段的宽度设得尽可能小：char 的上限为 255 字节（固定占用空间），varchar 的上限 65535 字节（实际占用空间），text 的上限为 65535。
尽量把字段设置为 NOT NULL，执行查询的时候，数据库不用去比较 NULL 值。

**2、使用联合 (UNION) 来代替手动创建的临时表**
把需要使用临时表的两条或更多的 SELECT 查询合并的一个查询中。

**3、使用索引**
查询语句当中包含有 MAX (), MIN () 和 ORDERBY 这些命令的时候，性能提高更为明显。
索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。

## 9、mysql索引失效的场景？

1. **对索引列进行函数操作**： 当在查询条件中对索引列进行函数操作时，例如使用`LOWER`、`UPPER`、`DATE`等函数，会导致索引失效。因为在进行函数操作后，索引无法直接匹配到预期的值，而是需要对整个索引进行扫描。
2. **使用`OR`或`NOT`操作符**： 在查询条件中使用`OR`或`NOT`操作符时，可能会导致索引失效。因为这些操作符会导致查询优化器无法确定正确的索引使用方式，从而选择不使用索引，而是进行全表扫描。
3. **LIKE模糊查询以通配符开头**： 当使用LIKE模糊查询时，如果通配符出现在查询模式的开头，例如`LIKE '%keyword'`，索引将无法被利用，因为需要对整个索引进行扫描。
4. **数据列类型不匹配**： 当查询条件和索引列类型不匹配时，索引将失效。比如在索引列是字符串类型，但查询条件是数字类型，或者索引列是整型，但查询条件是字符串类型。
5. **非前缀索引的使用**： 如果在使用联合索引时，没有按照联合索引的左侧连续字段进行查询，那么索引将无法被利用，从而导致索引失效。
6. **值分布不均匀**： 当索引的值分布不均匀时，会导致索引失效。例如某个列的大部分值都相同，或者某些值的重复度非常高，那么使用该索引可能会导致大量的数据行需要进行回表查询，从而降低性能。
7. **表数据量较小**： 当表中的数据量较小时，使用索引可能不如全表扫描高效，因为索引需要额外的I/O操作。在这种情况下，MySQL可能会选择不使用索引而直接进行全表扫描。

## **10.MyISAM与InnoDB 的区别:**

1.InnoDB支持事务，MyISAM不支持。

2.InnoDB支持外键，MyISAM不支持，

3.InnoDB是簇聚索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的，MyISAM是非簇聚索引，也是用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。

4.InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量，速度很快（不能加有任何WHERE条件）；

5.Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了.

6.MyISAM表格可以被压缩后进行查询操作.

7.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

8.InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有

9.Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI

Innodb：frm是表定义文件，ibd是数据文件

Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

## 11、数据库三范式

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。    

第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。    

第三范式：任何非主属性不依赖于其它非主属性。

## 12、超键、候选键、主键、外键分别是什么？

-    超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。    
-    候选键：是最小超键，即没有冗余元素的超键。    
-    主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。    
-    外键：在一个表中存在的另一个表的主键称此表的外键。

## 13、SQL 约束有哪几种？

1. 主键约束（Primary Key Constraint）：用于定义表中一列或多列的主键。主键的值必须是唯一的且不能为空，用于标识表中的每一行数据。
2. 唯一约束（Unique Constraint）：用于确保一列或多列的值是唯一的。与主键不同的是，唯一约束允许空值。
3. 非空约束（Not Null Constraint）：用于保证一列的值不能为空。非空约束要求该列在插入或更新时必须包含有效的非空值。
4. 外键约束（Foreign Key Constraint）：用于建立表与表之间的关系。外键约束定义了一列或多列与另一个表的主键或唯一键之间的引用关系，用于维护数据的完整性。
5. 检查约束（Check Constraint）：用于定义列的取值范围或满足某个条件的值。通过检查约束，可以限制数据的输入范围，确保符合特定的业务规则。

## 14、mysql索引的底层结构是什么？为什么使用索引查询快？

在 MySQL 中，常用的索引底层结构是**B+树**。

**特点：**

1. 所有数据都存储在叶子节点上，非叶子节点只存储索引键和指向下一层节点的指针。
2. 叶子节点之间通过双向链表连接，这样可以支持范围查询。
3. B+树的高度相对较低，磁盘IO次数少，适用于大规模数据的读取。

### 14.1、B+树为什么快？

**概述：**

1.B+树减少了IO次数，效率更高(B+树的高度相对于B树低) （这里这么理解：-----就是减少了磁盘的访问次数，毕竟内存速度要比磁盘快的多） 

2.B+树查询跟稳定，因为所有数据放在叶子节点 

3.B+树范围查询更好，因为叶子节点指向下一个叶子结点（叶子节点形成双向链表）



**详解：**

1. 高度平衡：B+树是一种自平衡的树结构，在插入和删除操作时会自动进行平衡调整，使得树的高度保持相对稳定。相比于二叉搜索树等其他树结构，B+树的高度通常较小，从根节点到叶子节点的路径长度相对较短，因此查询的时间复杂度也相对较低。
2. 分级索引：B+树的内部节点只存储键值信息而不存储数据本身，数据都存储在叶子节点上。这种分级索引的方式可以大幅减少内部节点的数量，使得每次查询时需要访问的节点数目减少。另外，由于叶子节点形成了一个有序链表，可通过遍历叶子节点来实现范围查询。
3. 顺序访问性能好：由于B+树的叶子节点形成了一个有序链表，通过遍历叶子节点可以实现顺序访问，这对于范围查询和区间扫描非常高效，避免了频繁的磁盘寻址操作。
4. 磁盘预读特性：B+树的节点大小通常设置为磁盘页的大小，这样每次从磁盘读取一个节点时，往往会预读相邻的节点。由于磁盘I/O是相对较慢的操作，通过预读可以提高磁盘访问性能，减少磁盘IO次数。
5. 可调整的阶数：B+树的阶数（即节点的最大子节点数量）可以根据需求进行调整。较大的阶数可以提高树的更新性能，适应频繁的插入和删除操作；较小的阶数则可以节省内存空间，适用于磁盘存储等资源受限的环境

## 15、一个sql查询可以几个索引？复合索引应该按什么顺序建?

mysql中一个查询只能使用一个索引，

**顺序：**

1、已知查询条件中包括的字段顺序，应该按照查询条件中列的顺序建立联合索引。

2、对于复合索引中的多个字段，应该选择区分度最高的字段放在前面。所谓区分度，是指某一字段中不同值的个数占全部记录的比例。区分度高的字段可以更快地缩小查询范围。

3、还可以通过分析查询语句的执行计划，根据复合索引使用情况的统计信息，选择最优的联合索引顺序。



# redis面试题

## 1、缓存穿透、缓存击穿、缓存雪崩

|          | 缓存穿透                                               | 缓存击穿                                                     | 缓存雪崩                                                     |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 描述     | 查询不存在的数据                                       | 某小段时间大量相同查询达到存储层                             | 缓存无法提供服务，大量请求打到存储层                         |
| 可能原因 | 1. 缓存和库中数据被删除 2. 恶意攻击                    | 某些热点数据过期失效                                         | 大量数据过期，或Redis宕机                                    |
| 解决方法 | 1. 缓存空对象，未命中时将空值存入缓存2. 布隆过滤器拦截 | 1. 热点数据永不过期 2. 互斥加锁，多线程访问redis某key无数据时，只有一个线程能去存储层查询并存入redis，然后其它线程再从redis取数据 | 1. 避免数据同时过期，设置过期时间为随机值 2. 降级和熔断，对于非核心请求直接返回预定义信息 3. 构建高可用服务 |

## 2、redis为什么快？

1、单线程处理命令避免上下文切换和线程竞争带来的开销
2、数据存储在内存
3、c语言本身性能高
4、IO多路复用技术，实现高吞吐的网络IO UNIX IO五种模型

## 3、Redis的线程

从 Redis 的 v1.0 到 v6.0 版本之前，Redis 的核心网络模型一直是一个典型的单 Reactor 模型。Redis v6.0 才改造成多线程模式。

Redis的主要瓶颈是内存和网络带宽，而非CPU。6.0引入多线程解决网络IO问题。

### 3.1、版本变更中的多线程

涉及的多线程
Redis 3.0前	1. 持久化：BGSAVE和BGREWRITEAOF会fork子进程进行

### 3.2、异步任务：关闭文件、将缓冲区冲洗到磁盘文件中

Redis 4.0	异步删除键值对的命令：UNLINK（DEL的异步版本）、FLUSHALL ASYNC、FLUSHDB ASYNC（删除选项，整个数据集还是单个数据库）
Redis 6.0	socket读写、请求解析是多线程，但命令执行是单线程（键值对操作，防止线程不安全）

### 3.3、Redis核心为什么使用单线程

1、避免上下文切换
2、避免同步机制带来开销
3、简单可维护

## 4、redis有哪些数据结构

1. **字符串（String）**：用于存储文本或二进制数据。底层结构是**简单动态字符串**（**SDS**）。
2. **哈希表（Hash）**：用于存储键值对集合。底层结构是**哈希表**，通过哈希算法快速定位到对应的键值对。
3. **列表（List）**：用于存储有序的字符串元素集合。底层结构是**双向链表**。
4. **集合（Set）**：用于存储无序的唯一字符串元素集合。底层结构可以是**哈希表**或**有序整数数组**。
5. **有序集合（Sorted Set）**：用于存储有序的唯一成员和对应的分数（score）值。底层结构是**跳跃表**和**哈希表**的组合。
6. **Bitmap**：用于存储位操作相关的数据。底层结构是**字符串**。
7. **HyperLogLog**：用于基数估算（cardinality estimation）的数据结构。底层结构是**字符串**或**稀疏数组**。
8. **地理空间索引（GeoSpatial）**：用于存储地理空间信息的数据结构。底层结构是**跳跃表**和**哈希表**的组合。

### 4.1、SDS

**1、SDS结构体**

```c
struct sdshdr {
    // buf中已使用的长度
    int len;
    // buf中未使用的长度
    int free;
    // 数据空间
    char buf[];
}
```

这个结构体说明了SDS字符串的长度和未使用的空间大小，以及数据本身。这种设计使得我们能够在常数时间内获取字符串的长度。

**2、动态扩容**

假设我们有一个SDS字符串，并且想要在其后添加一些字符。在SDS中，这个操作是这样实现的：

```
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}
```

`sdscatlen`函数检查SDS字符串的未使用空间是否足够。如果不足，它会重新分配内存，确保有足够的空间存储新的字符。这个过程是透明的，避免了C字符串的缓冲区溢出问题。

**3、二进制安全**

SDS是二进制安全的，这意味着你可以在SDS中存储任何类型的数据，包括二进制数据。例如：

```c
// 创建一个包含图片数据的SDS
sds s = sdsnewlen(my_image_data, my_image_size);
```

**4、性能优化**
SDS通过预分配策略和惰性空间释放策略优化性能：

预分配策略：当SDS字符串需要扩展时，除了为要添加的字符分配空间外，还会分配额外的未使用空间。
惰性空间释放策略：当SDS字符串缩短时，SDS不会立即释放多余的内存空间，而是保留这些空间作为未使用空间。
这些设计使得SDS在处理大型字符串时性能出色，且内存利用率高。

**5、兼容C字符串**
虽然SDS在很多方面都比C字符串优秀，但它仍然保持了与C字符串的兼容性。例如，SDS字符串的buf数组总是以空字符'\0'结束，这样可以确保任何期望C字符串的函数都可以正确处理SDS。

SDS是Redis强大性能的关键因素之一。它提供的特性使得Redis能够有效地处理各种数据，包括大型数据和二进制数据，同时保持了高性能和内存效率。


## 5、redis大key问题

**什么是大key？：**
value值占用内存较大

**有什么影响：**
网络传输内容大，占用带宽，服务端和客户端的读取耗时增加
可能是热key，频繁读取影响性能
大key用del删除时，会阻塞线程
可能带来分布式系统中的数据倾斜，资源利用率不平衡
在集群中，数据迁移困难（migrate 命令是通过 dump 和 restore 和 del 三个命令组合成原子命令完成，如果是存在 bigkey 的话，可能会因为大 value 的原因导致迁移失败，而且较慢的 migrate 会阻塞 Redis，影响 Redis 服务）
**如何产生：**
一般是因为业务涉及不合理，没有预计value动态增长

一直往value里塞数据，没有删除或者限制机制
数据没有进行分片，将大key变为小key
**如何排查：**
利用redis-cli bigkeys命令，在线扫描（不会阻塞）
利用redis-rdb-toos，离线分析RDB持久化文件，实时性差，但是完全离线对性能无影响
**如何解决：**
删除： 先用scan渐进式查找key，（用keys * 会阻塞）
低于4.0版本，除了string类型，其他类型都可以每次用del删除一部分
高于4.0版本，可以使用unlink直接异步删除
压缩与拆分：
string类型：难以拆分，可以序列化、压缩。但是会增加额外耗时
hash类型 ：字段拆分，将一个对象分为多个部分，读取时可以使用multiget事务读取
list、set类型：可以通过计算分片到不同的集群节点上

## 6、布隆过滤器（待补充）

### 6.1、什么是布隆过滤器？

布隆过滤器（Bloom Filter）是一种用于快速判断一个元素是否属于一个集合的概率型数据结构。

它通过使用一个**位数组**（通常是由二进制位组成），以及多个哈希函数来实现。位数组的长度事先确定，每个位置都初始化为0。对于要加入布隆过滤器的元素，将其经过多个哈希函数的计算，得到多个哈希值，然后将相应的位数组位置设置为1。判断元素是否存在时，同样将元素经过相同的哈希函数计算，检查对应的位数组位置是否都为1。

布隆过滤器具有以下特点：

1. 快速查询：布隆过滤器的查询时间复杂度很低，通常为O(k)，其中k是哈希函数的数量。
2. 空间效率高：布隆过滤器仅需要占用较少的内存空间，位数组的大小相对于集合的大小是可控的。
3. 可能会存在误判：布隆过滤器在判断一个元素不在集合中时，可以保证100%的准确性。但当判断一个元素在集合中时，存在一定的概率出现误判，即将一个不存在的元素误判为存在。
4. 不支持删除操作：布隆过滤器无法删除已插入的元素，因为删除操作会影响其他元素的判断结果。

布隆过滤器常见的应用场景包括缓存击穿、垃圾邮件过滤、URL去重等。通过合理设置位数组大小和哈希函数的数量，并控制误判率，可以在很多实际场景中实现高效的去重和查询功能。

### 6.2、什么时候会用到布隆过滤器？

1. 垃圾邮件过滤：布隆过滤器可以用于快速判断一封邮件是否是垃圾邮件。通过将已知的垃圾邮件地址或特定的邮件特征添加到布隆过滤器中，可以快速过滤掉大量的垃圾邮件，提高过滤效率。
2. 缓存管理：布隆过滤器可以用于缓存管理中，快速判断一个对象是否存在于缓存中。通过将缓存中的关键字或者哈希值添加到布隆过滤器中，可以避免不必要的查询操作，提高缓存的命中率。
3. URL去重：在爬虫系统中，布隆过滤器可以用于URL去重，避免重复抓取相同的URL。通过将已访问的URL添加到布隆过滤器中，可以快速判断一个URL是否已经被抓取过，从而提高爬取效率。
4. 分布式系统中数据同步：在分布式系统中，布隆过滤器可以用于快速判断某个数据是否存在于其他节点中。通过将数据的关键字或哈希值添加到布隆过滤器中，可以快速判断数据是否已被其他节点保存，从而避免不必要的网络通信和数据传输。
5. 数据库查询优化：在某些情况下，布隆过滤器可以用于数据库查询优化。例如，在一个大型用户表中，可以使用布隆过滤器判断某个用户是否存在于表中，如果不存在则可以避免进行具体的数据库查询操作，减轻数据库负载。

### 6.3、布隆过滤器什么时候会误判？怎么解决？

布隆过滤器在某些情况下可能会出现误判，即将一个不存在的元素误认为存在。布隆过滤器的误判主要由以下两个因素引起：

1. 哈希冲突：当多个元素经过哈希函数计算后得到相同的位数组索引位置时，就会发生哈希冲突。这可能导致不同的元素被映射到相同的位上，从而造成误判。
2. 已存在元素的相似性：如果要查询的元素与已存在的元素在哈希函数计算后的位数组索引位置有部分重叠或完全重合，就有可能发生误判。

为了减少误判的发生，可以采取以下方法：

1. 使用多个独立的哈希函数：使用多个不同的哈希函数来计算元素的哈希值，并将对应的位数组位置设置为1。这样可以减少哈希冲突的概率，从而降低误判的风险。
2. 选择适当的位数组大小和哈希函数数量：通过根据预期插入元素数量和可接受的误判率，选择合适的位数组大小和哈希函数数量。调整这些参数可以平衡布隆过滤器的性能和误判率。
3. 结合其他数据结构进行验证：由于布隆过滤器无法从误判中恢复，可以将布隆过滤器作为第一层筛选机制，并结合其他数据结构（如哈希表、数据库等）进行进一步验证。这样可以提高查询结果的准确性。

总的来说，布隆过滤器是一种在空间和时间效率上具有优势的数据结构，但它不是完全准确的。通过调整参数、使用多个哈希函数以及结合其他数据结构进行验证，可以降低布隆过滤器的误判率。

## 7、stream

# 容器面试题

## 1、什么是容器化？与传统虚拟化有何区别？ 

容器化是将应用程序及其依赖项打包在一个独立的运行环境中，以便可以在任何环境中进行部署和运行。与传统虚拟化相比，容器化更加轻量级，因为它们共享操作系统内核，并且更快速地启动和停止。

## 2、解释一下 Docker 是什么，它的核心原理是什么？

 Docker 是一种流行的容器化平台，它提供了一个简单而强大的方式来创建、部署和运行容器。Docker 的核心原理是利用 Linux 内核的命名空间（namespace）和控制组（cgroup）功能，实现容器之间的隔离和资源管理。

## 3、Kubernetes 是什么？它用于解决什么问题？ 

Kubernetes 是一个开源的容器编排平台，用于自动化容器的部署、扩展和管理。它解决了容器化环境中的服务发现、负载均衡、故障恢复等问题，并提供了强大的编排和调度能力。

## 4、如何将一个应用程序容器化，并编写 Dockerfile？ 

可以通过创建一个 Dockerfile 文件来容器化应用程序。Dockerfile 是一个文本文件，其中包含了一系列的指令，用于构建容器镜像。通过定义基础镜像、复制文件、安装依赖和设置运行命令等步骤，可以将应用程序打包成一个可运行的容器。

## 5、k8s如何实现服务注册和负载均衡

1. 服务注册： 在Kubernetes中，服务通过创建一个抽象的资源对象叫做Service来进行注册。Service定义了一组Pod的逻辑分组，并为这些Pod提供了一个稳定的虚拟IP地址和端口。当Service创建时，它会自动分配一个唯一的DNS名称。其他的Pod或外部服务可以使用这个DNS名称来访问Service。

2. 负载均衡： Kubernetes中的Service会为后端的Pod实例提供负载均衡。当请求到达Service所在的虚拟IP地址时，负载均衡器会将请求转发到后端的Pod实例上。

   a. 集群内部负载均衡：Kubernetes会在每个节点上创建一个iptables规则，将Service的虚拟IP地址映射到后端Pod的真实IP地址，并使用Round Robin算法进行负载均衡。

   b. 集群外部负载均衡：如果需要将服务暴露给集群外部的客户端，Kubernetes可以通过集成外部负载均衡器来实现。例如，可以使用云服务商提供的负载均衡器（如AWS ELB、GCP Load Balancer）或者独立的Ingress控制器来处理外部流量的转发。

## 6、Ingress和Service有什么区别

1. Service：
   - Service 是 Kubernetes 中的一个内部抽象，为一组 Pod 定义了一个稳定的网络端点。
   - Service 允许 Pod 之间进行通信和负载均衡，在不影响连接性的情况下实现部署的扩展和更新。
   - Service 可以在集群内部（ClusterIP）、对外部客户端（NodePort 或 LoadBalancer）或仅内部使用（Headless）进行公开。
   - Service 在 OSI 模型的第四层（传输层）工作，使用 IP 地址和端口号。
2. Ingress：
   - Ingress 是一个更高级的 API 对象，为集群内的服务提供对外访问。
   - Ingress 充当流量入口，根据 Ingress 资源中指定的主机名、路径或其他规则，将请求从集群外路由到相应的 Service 上。
   - Ingress 允许配置 TLS 终止、虚拟主机和基于 URL 的 HTTP/HTTPS 流量路由。
   - Ingress 在 OSI 模型的第七层（应用层）工作，检查 HTTP/HTTPS 请求并根据规则进行相应的操作。

简而言之，Service 提供集群内部的网络连接和负载均衡，而 Ingress 提供对集群内部服务的外部访问和高级路由功能。Service 管理内部网络，而 Ingress 管理外部网络入口。

## 7、容器是如何实现隔离的？隔离了什么？

1. **进程隔离**： 容器使用Linux命名空间（namespaces）技术，将各个容器的进程隔离开，使得每个容器都具有独立的进程空间，从而避免了进程之间的干扰。每个容器都有自己的PID命名空间，使得容器中的进程对于其他容器和主机上的进程是不可见的。
2. **文件系统隔离**： 容器使用Linux的UnionFS（联合文件系统）技术，将底层镜像文件系统与容器私有的写时复制（Copy-on-Write）层相结合。这样每个容器都可以拥有自己的文件系统，但又与主机和其他容器共享基础镜像的文件系统。这样既实现了文件系统的隔离，同时也节省了存储空间。
3. **网络隔离**： 容器使用Linux的网络命名空间技术，为每个容器提供独立的网络栈，包括独立的IP地址、网络接口、路由表等。这样容器之间的网络通信是相互隔离的，可以使用不同的端口和协议。
4. **资源隔离**： 容器可以使用Linux的cgroups（控制组）机制来限制容器对资源的使用，如CPU、内存、磁盘I/O等。这样可以确保容器的资源使用在一定范围内，防止一个容器耗尽主机的资源，影响其他容器的正常运行。

## **8、简述下etcd以及在他在k8s中的作用**

etcd 是一个可靠、高性能的分布式键值存储系统，提供了强一致性、容错性和简单易用的 API，可以广泛应用于分布式系统中的配置管理、服务发现、分布式锁等场景。

**特点：**

1. 一致性：etcd 使用 Raft 算法来实现分布式一致性，确保在各个节点之间的数据强一致性。Raft 提供了选举、日志复制和安全性的保证，使得 etcd 可以容忍节点故障，提供高可用性。
2. 可靠性：etcd 将数据持久化到磁盘上，即使在节点故障、网络分区或系统重启的情况下，也能保证数据的可靠性和一致性。它使用日志复制机制来保证数据的可恢复性，并支持快速故障转移，确保服务的可用性。
3. 简单的 API：etcd 提供了简单易用的 RESTful API，可以通过 HTTP 或 gRPC 进行访问。应用程序可以使用基本的 CRUD 操作对键值对进行读写操作，也支持一些高级操作如事务和 Watch。
4. 高性能：etcd 使用了内存缓存技术和批量操作优化等策略，提供了很高的读写性能和低延迟。它还支持自动压缩和自动过期等功能，帮助节约存储和提高数据访问效率。
5. 分布式：etcd 可以在多个节点上进行部署，形成一个分布式集群。它使用选举机制选举一个 Leader 节点，负责处理客户端请求和日志复制。其他节点作为 Follower 节点，通过与 Leader 节点保持心跳来保持同步。
6. 可扩展性：etcd 集群可以根据需求进行水平扩展。当需要增加更多节点时，可以简单地添加新节点到现有集群，etcd 会自动进行重新平衡和数据迁移，无需停机或应用程序修改。

**在k8s中的作用**

1. 存储集群状态：etcd 在 K8s 中被用来存储集群的整体状态信息，包括节点的状态、Pod 的状态、服务和副本控制器的信息等。这些状态信息被保存为键值对的形式，并通过 etcd 的分布式特性来保证高可用性和一致性。
2. 服务发现：Kubernetes 中的服务发现依赖于 etcd 来存储和维护服务的相关信息。当一个服务被创建时，它的 IP 地址和端口信息会被注册到 etcd 中，其他服务可以通过查询 etcd 获取到这些信息，从而实现服务之间的通信。
3. 配置管理：etcd 也被用于存储和管理应用程序的配置信息。在 Kubernetes 中，ConfigMap 对象用于将配置数据存储在 etcd 中，应用程序可以通过挂载 ConfigMap 来获取最新的配置信息，当配置发生变化时，应用程序能够自动感知到并更新配置。
4. 调度和容灾：etcd 的高可用特性使得 K8s 可以在集群中运行多个 etcd 节点，通过选举一个 Leader 提供服务。这样即使某些节点发生故障，集群仍然能够继续正常工作，保证服务的高可用性和容灾能力。
5. 水平扩展：etcd 的分布式架构使得 K8s 可以轻松地进行水平扩展。当需要增加更多的节点时，可以简单地添加新的 etcd 节点到集群中，数据会自动进行重新平衡和迁移，无需停机或修改应用程序。

## 9、简述一下pod的重启策略

在 Kubernetes 中，可以通过设置 Pod 的重启策略来定义当 Pod 处于失败状态时的行为。Pod 的重启策略主要有以下三种：

1. Always（默认策略）：无论何时，只要 Pod 处于失败状态，Kubernetes 就会自动尝试重启该 Pod。这适用于大多数应用程序，确保在发生故障时快速恢复。
2. OnFailure：只有当 Pod 处于非零退出状态（例如应用程序崩溃或发生错误）时才会重启 Pod。如果 Pod 成功地终止，即使其退出代码为零，也不会触发重启操作。
3. Never：Pod 处于任何状态下都不会自动重启。这通常用于需要手动控制重启的特殊情况，例如调试或需要人工介入才能进行恢复的场景。

# Linux面试题

## 命令集

### 磁盘管理

**df**：命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。

- 文件-a, --all 包含所有的具有 0 Blocks 的文件系统
- 文件--block-size={SIZE} 使用 {SIZE} 大小的 Blocks
- **文件-h, --human-readable 使用人类可读的格式(**预设值是不加这个选项的...)
- 文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024
- 文件-i, --inodes 列出 inode 资讯，不列出已使用 block
- 文件-k, --kilobytes 就像是 --block-size=1024
- 文件-l, --local 限制列出的文件结构
- 文件-m, --megabytes 就像 --block-size=1048576
- 文件--no-sync 取得资讯前不 sync (预设值)
- 文件-P, --portability 使用 POSIX 输出格式
- 文件--sync 在取得资讯前 sync
- 文件-t, --type=TYPE 限制列出文件系统的 TYPE
- 文件-T, --print-type 显示文件系统的形式
- 文件-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE
- 文件-v (忽略)
- 文件--help 显示这个帮手并且离开
- 文件--version 输出版本资讯并且离开

**du**：显示指定的目录或文件所占用的磁盘空间。

- -a或-all 显示目录中个别文件的大小。
- -b或-bytes 显示目录或文件大小时，以byte为单位。
- -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
- -D或--dereference-args 显示指定符号连接的源文件大小。
- **-h或--human-readable 以K，M，G为单位，提高信息的可读性。**
- -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
- -k或--kilobytes 以1024 bytes为单位。
- -l或--count-links 重复计算硬件连接的文件。
- -L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。
- -m或--megabytes 以1MB为单位。
- **-s或--summarize 仅显示总计。**
- -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
- -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
- -X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。
- --exclude=<目录或文件> 略过指定的目录或文件。
- **-d或--max-depth=<目录层数> 超过指定层数的目录后，予以忽略。（常用）**
- --help 显示帮助。
- --version 显示版本信息。



## 1、操作系统内核态和用户态的区别

内核态是操作系统的特权模式，具有最高的权限。在内核态下，CPU 可以执行任意的机器指令，并访问所有的计算机资源，如内存、设备等。内核态主要用于执行操作系统核心代码，控制硬件资源、管理进程和文件系统等底层操作。

用户态是应用程序的一种运行模式，具有较低的权限。在用户态下，CPU 受限制只能执行受限的指令，并且只能访问用户空间的资源。用户态不允许直接访问核心资源，必须通过系统调用接口向操作系统发起请求，由操作系统在内核态下执行相应的请求操作。

区别：

1. 权限级别：内核态具有最高权限，可以执行所有机器指令并访问所有计算机资源；用户态权限较低，受限于操作系统的保护机制，无法直接访问核心资源。
2. 资源访问：内核态可以直接访问系统的核心资源，如物理内存、硬盘、网络设备等；用户态只能通过系统调用接口向操作系统请求访问核心资源。
3. 运行环境：内核态运行操作系统的核心代码，控制和管理计算机硬件资源；用户态运行应用程序，通过系统调用接口向操作系统请求服务。
4. 安全性：内核态的代码需要经过严格的测试和验证，以确保操作系统的正确性和安全性；用户态的应用程序受限于操作系统的保护机制，可以提高系统的稳定性和安全性。

## 2、Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？

（1）不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。

（2）暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。

“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。

（3）就绪状态：在 run_queue 队列里的状态

（4）运行状态：在 run_queue 队列里的状态

（5）可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起

（6）zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉

（7）退出状态



# 安全面试题

## 1、什么是对称加密？什么是非对称加密？

对称加密：

对称加密是指使用同一个密钥进行加密和解密的加密算法。发送方使用密钥对数据进行加密，然后将加密后的数据发送给接收方，接收方再使用同样的密钥对数据进行解密。常见的对称加密算法包括**DES**、**AES**和**RC4**等。对称加密算法具有加密速度快、效率高的特点，适合用于大量数据的加密和解密。然而，对称加密存在一个密钥分发问题，即如何安全地将密钥传输给接收方。



非对称加密：

非对称加密也被称为公钥加密，它使用一对相关联的密钥：公钥和私钥。发送方使用接收方的公钥对数据进行加密，只有持有相应私钥的接收方才能解密该数据。相比于对称加密，非对称加密更为安全，因为公钥可以自由发布而不会泄露私钥。一些常见的非对称加密算法包括**RSA**和Elliptic Curve Cryptography (**ECC**)。然而，非对称加密算法相对而言较为复杂，加密和解密的速度较慢，不适合加密大量数据。
