# GO面试题

### **1、golang 中 make 和 new 的区别？（基本必问）**

**共同点：**给变量分配内存，内存都是分配在**堆**上

**不同点：**

1）作用变量类型不同，new给string,int和数组分配内存，make给**切片，map，channel**分配内存；

2）返回类型不一样，new返回指向变量的指针，make返回变量本身；

3）new 分配的空间被清零。make 分配空间后，会进行初始化；





### **2、数组和切片的区别 （基本必问）**

**相同点：**

1)只能存储一组相同类型的数据结构

2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取

**区别：**

1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容

2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

**简洁的回答：**

1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。



### **3、for range 的时候它的地址会发生变化么？**

答：在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。

### **4、go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？**

作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;

避坑指南：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。

多个 defer 调用顺序是 LIFO（**后入先出**），defer后的操作可以理解为压入栈中

defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：**有名返回值或者函数返回指针** 参考：

[【Golang】Go语言defer用法大总结(含return返回机制)__奶酪的博客-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Cassie_zkq/article/details/108567205)

### **5、uint 类型溢出问题**

超过最大存储值如uint8最大是255

var a uint8 =255

var b uint8 =1

a+b = 0总之类型溢出会出现难以意料的事

![img](image/go基础.images/v2-5bf5e213ce315a16d0b7e65ef41cc685_b.webp)

### **6、能介绍下 rune 类型吗？**

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

byte 等同于int8，常用来处理ascii字符

rune 等同于int32,常用来处理unicode或utf-8字符

![img](image/v2-15a9656d176cfcc16d4116bbc9d2a24d_b.webp)

#### 6.1、rune和int32有什么区别？为什么需要rune类型？

`rune` 和 `int32` 都是 Go 语言中的数据类型，但在某些情况下它们有不同的用途和含义。

1. `int32` 是一个整数类型，它占用 4 个字节（32 位），可以表示范围内的整数值，包括负数和正数。`int32` 是基本的整数类型，可用于进行算术运算、比较操作等。
2. `rune` 也是一个整数类型，但它专门用来表示 **Unicode 码点（code point）**。Unicode 是一种国际编码标准，用来表示世界上所有字符的唯一编码。每个 Unicode 字符都对应一个唯一的码点，而 `rune` 就是用来存储这个码点的整数值的数据类型。

为什么需要 `rune` 类型呢？

在 Go 语言中，字符串是由多个字符组成的，而字符可能不仅仅是一个字节，有些字符可能由多个字节组成（比如中文字符）。为了正确处理和操作字符串中的字符，需要使用 `rune` 类型来表示字符的 Unicode 码点。通过使用 `rune` 类型，可以确保在字符串中能够正确地表示和处理各种语言的字符，包括特殊符号、表情符号等。

`rune` 类型还可以用于迭代字符串中的字符，例如使用 `for range` 循环遍历字符串时，得到的每个元素将被解释为 `rune` 类型，这样可以确保正确处理字符串中的字符而不是字节。

总结起来，`int32` 是 Go 语言中的整数类型，而 `rune` 是专门用来表示 Unicode 码点的整数类型。使用 `rune` 类型可以保证在处理字符串时能够正确地处理和表示各种字符，以满足多语言、多字符集的需求。

### **7、 golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级肯定会问，比较难，需要自己多去总结)**

在 Go 中，解析结构体字段的标签是通过反射实现的。反射（reflection）是指在程序运行时动态地检查类型信息和修改对象的能力。在 Go 中，`reflect` 包提供了一组用于进行反射操作的函数和类型。

#### 7.1、自定义序列化方式？

在 Golang 中，我们可以通过实现 `encoding.Marshaler` 和 `encoding.Unmarshaler` 接口来自定义类型的序列化和反序列化方式。

### **8、golang 调用函数传入slice、map、chan、结构体分别是值传递还是引用传递？ （Golang 都是传值）**

首先需要明确 Go 中**只有值传递**，没有传统意义上的引用传递。但是某些类型的行为会让人感觉像是引用传递，这是因为它们内部包含指针。

| 类型    | 传递方式 | 函数内修改元素 | 函数内扩容/重新赋值 |
| :------ | :------- | :------------- | :------------------ |
| Slice   | 值传递   | 影响原值       | 不影响原值          |
| Map     | 值传递   | 影响原值       | 影响原值            |
| Channel | 值传递   | 影响原值       | 影响原值            |
| 结构体  | 值传递   | 不影响原值     | 不影响原值          |

1. Go 中**所有参数传递都是值传递**

2. Slice、map 和 channel 由于内部包含指针，所以函数内修改元素会影响外部

3. 结构体是完全的值传递，修改不影响外部

4. 如果需要完全共享变量，应该使用指针（`*T`）

   

### **9、讲讲 Go 的 slice 底层数据结构和一些特性？**

答：Go 的 slice 底层数据结构是由一个 array 指针指向**底层数组**，**len 表示切片长度，cap 表示切片容量**。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）

#### 9.1、slice的扩容机制？

**一、go1.18 之前：**

1. 如果期望容量大于当前容量的两倍就会使用期望容量；
2. 如果当前切片的长度小于 **1024** 就会将容量翻倍；
3. 如果当前切片的长度大于 **1024** 就会每次增加 25% 的容量，直到新容量大于期望容量；

**二、go1.18 之后：**

1. 如果期望容量大于当前容量的两倍就会使用期望容量；
2. 如果当前切片的长度小于阈值**（默认 256）**就会将容量翻倍；
3. 如果当前切片的长度大于等于阈值**（默认 256）**，就会每次增加 25% 的容量，基准是 `(newcap + 3*threshold) / 4`，直到新容量大于期望容量；

实际上，`growslice` 的后半部分还有更进一步的优化（内存对齐等），靠的是 `roundupsize` 函数，在计算完 `newcap` 值之后，还会有一个步骤计算最终的容量：

```go
capmem = roundupsize(uintptr(newcap) * ptrSize)
newcap = int(capmem / ptrSize)
```

这个函数的实现就不在这里深入了，先挖一个坑，以后再来补上。

### **10、Go 的 select 底层数据结构和一些特性？**

答：

在 Go 中，`select` 语句是用于处理多个通道操作的选择器。下面是 `select` 的底层数据结构和一些特性：

1. 底层数据结构：`select` 语句的底层数据结构是一个无限循环，它会不断地检查每个 case 语句，并根据条件执行相应的操作。
2. 多路复用：`select` 语句可以同时监听多个通道的读写操作。当有一个或多个通道就绪时，`select` 会随机选择其中一个 case 执行对应的操作。
3. 随机选择：如果多个 case 同时就绪，即可读或可写，`select` 语句会随机选择其中一个 case 执行，确保选择的公平性。
4. 阻塞和非阻塞：当所有的 case 都未就绪时，`select` 语句会阻塞等待，直到至少有一个 case 就绪。如果希望在没有任何 case 就绪时立即返回，可以使用 `default` case 实现非阻塞的操作。
5. 超时控制：通过在 `select` 语句中嵌入一个带有定时器的 case 语句，可以实现超时控制。当其他 case 都未就绪时，定时器 case 就会触发，从而避免无限等待。
6. `select` + `for` 循环：通常会将 `select` 语句与 `for` 循环结合使用，以实现重复监听多个通道的操作。通过在 `for` 循环中使用 `select`，可以不断地尝试执行不同的 case。



**select 的特性**

1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）多个 case 语句的执行顺序是随机的。

5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

### **11、讲讲 Go 的 defer 底层数据结构和一些特性？**

答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 goroutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照**后进先出**的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。

### **12、单引号，双引号，反引号的区别？**

单引号，表示**byte**类型或**rune**类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。

双引号，才是**字符串**，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。

反引号，表示**字符串字面量**，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。

### 13、值类型和引用类型分别有哪些？

1、值类型（Value types）：

- 布尔类型（bool）
- 数字类型（整型、浮点型、复数型）
- 字符串类型（string）
- 数组类型（array）
- 结构体类型（struct）

2、引用类型（Reference types）：

- 切片类型（slice）
- 映射类型（map）
- 函数类型（function）
- 通道类型（channel）
- 接口类型（interface）

3、指针类型

此外，指针类型（pointer）也可以被认为是一种特殊的引用类型，在Go中用来存储变量的内存地址。指针本身是值类型，但通过指针可以间接引用对象并进行修改。

### **14、go是否可以定制序列化和反序列的方式？**

可以，通过实现`json.Marshaler`和`json.Unmarshaler`接口，可以完全自定义对象的序列化和反序列化过程。在这些方法中，可以根据自己的需求对对象进行编码和解码。

### 15、go函数什么时候用值返回什么时候使用指针返回？

1、有状态的对象必须使用指针返回，如系统内置的 sync.WaitGroup、sync.Pool 之类的值，在 Go 中有些结构体中会显式存在 noCopy 字段提醒不能进行值拷贝；

2、生命周期短的对象使用值返回，如果对象的生命周期存在比较久或者对象比较大，可以使用指针返回；

3、大对象推荐使用指针返回，对象大小临界值需要在具体平台进行基准测试得出数据；

### 16、go协程中panic没有捕获会发生什么？

如果在 Go 协程中发生 panic，并且没有对其进行捕获和处理，那么会导致整个程序崩溃。

当没有显式地对协程中的 panic 进行处理时，**panic 会沿着协程的调用栈向上冒泡，直到达到顶层的协程（主协程）。在主协程中，发生未捕获的 panic 会导致整个程序停止执行，并输出 panic 的详细信息，包括错误信息和堆栈跟踪**。这是为了保证程序的健壮性和安全性。

未捕获的 panic 会导致程序的不可恢复错误，它表示程序遇到了无法处理的异常情况。因此，在编写 Go 代码时，应该尽量避免发生未捕获的 panic。可以使用 defer 和 recover() 来捕获和处理 panic，以及尽早检查和处理可能导致 panic 的错误条件。

需要注意的是，Go 语言鼓励使用错误值（error）来处理预期错误，而不是依赖于 panic。panic 应该被用于表示严重的错误或无法处理的异常情况，而不是作为正常的错误处理机制。

总结起来，如果在 Go 协程中发生 panic，并且没有对其进行捕获和处理，整个程序将停止执行并输出 panic 的详细信息，导致程序崩溃。因此，应该尽量避免未捕获的 panic，并使用错误值来处理预期错误。

#### 16.1、panic后会执行defer吗？

在发生 panic 后，程序会立即停止当前协程的执行，并且不会继续执行该协程中后续的代码。这意味着在 panic 之后的代码，包括在当前协程中使用 defer 关键字延迟执行的代码，将不会被执行。

defer 是一种用于延迟执行语句或函数调用的机制，它通常用于资源释放、清理或记录日志等操作。虽然在 panic 后 defer 中的代码不会被执行，但是在当前协程中的其他 defer 块中的代码仍然会得到执行。这些 defer 块按照定义的倒序依次执行，直到遇到恢复（recover）或者整个协程退出为止。

在发生 panic 时，如果在当前协程中存在与 panic 对应的 recover 函数，那么 panic 会被捕获并转化为 error 类型的返回值，同时协程的执行会从 panic 的位置继续进行，而不会立即终止。在这种情况下，后续的 defer 块中的代码仍然会得到执行。

需要注意的是，recover 只能在 defer 块中使用。如果在没有发生 panic 的情况下调用 recover，会返回 nil。此外，每个协程都拥有自己的 panic 和 recover 栈，不会影响其他协程。

总结起来，在发生 panic 后，当前协程会立即停止执行，并且不会执行当前协程中 panic 后的代码，包括 defer 中的代码。但其他协程中的 defer 块中的代码仍然会执行。如果在当前协程中存在与 panic 对应的 recover 函数，那么 panic 可能会被捕获并转化为 error 类型的返回值，此时协程的执行会从 panic 的位置继续进行，并执行后续的 defer 块中的代码。

## **二、map相关**

### 1、map 使用注意的点，是否并发安全？

map的类型是map[key]，key类型的ke必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，要保证struct对象在逻辑上是不可变的。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。

**第一，**一定要先初始化，否则panic

**第二，**map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的fatal error。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致fatal error，发生此错误时不能被捕获直接退出。

### 2、map 循环是有序的还是无序的？

**无序**的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种

### 3、 map的底层实现

golang中map的底层实现主要是**哈希表**，结构体有两个：hmap和bmap.

```go
type hmap struct {
    count      int            //元素个数，调用len(map)时直接返回
    flags      uint8          //标志map当前状态,正在删除元素、添加元素.....
    B          uint8          //单元(buckets)的对数 B=5表示能容纳32个元素
    noverflow  uint16        //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元
    hash0      uint32         //哈希种子
    buckets    unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil
    oldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍
    nevacute   uintptr        //指示扩容进度，小于此buckets迁移完成
    extra      *mapextra      //与gc相关 可选字段
}
buckets：一个指针，指向一个bmap数组、存储多个桶。
oldbuckets： 是一个指针，指向一个bmap数组，存储多个旧桶，用于扩容。
overflow：overflow是一个指针，指向一个元素个数为2的数组，数组的类型是一个指针，指向一个slice，slice的元素是桶(bmap)的地址，这些桶都是溢出桶。为什么有两个？因为Go map在哈希冲突过多时，会发生扩容操作。[0]表示当前使用的溢出桶集合，[1]是在发生扩容时，保存了旧的溢出桶集合。overflow存在的意义在于防止溢出桶被gc。
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
一个桶（bmap）可以存储8个键值对。如果有第9个键值对被分配到该桶，那就需要再创建一个桶，通过overflow指针将两个桶连接起来。在hmap中，多个bmap桶通过overflow指针相连，组成一个链表。
键和值是分开存放的，原因是当key和value类型不一样的时候，key和value占用字节大小不一样，使用key/value这种形式可能会因为内存对齐导致内存空间浪费，所以Go采用key和value分开存储的设计，更节省内存空间
```



哈希表的特点是根据哈希函数求得哈希值，来存储对应的key，golang中根据哈希值将其分为高位和低位；
低8位用于寻找当前key属于哪个hmap中的哪个bucket；而高8位用于确定将其存放在桶中（bucket）的哪个位置；
注意：一个桶内最多有8个位置。这也是为什么map无法使用cap()来求容量的关键原因：map的容量是编译器进行计算后得出的一个结果，由于桶的存在，map在内存中实际存放的大小不一定同make出来后的map的大小一致。

#### 3.1、问：map 中删除一个 key，它的内存会释放么？

通过delete删除map的key，执行gc不会，内存没有被释放，如果通过map=nil，再GC，内存才会释放

#### 3.2、问：nil map 和空 map 有何不同？

nil map是未初始化的map，空map是长度为空

#### 3.3、map并发是否安全？如何保证map的并发安全性？

map默认是并发不安全的，同时对map进行并发读写时，程序会panic

方式一：使用读写锁  map +  sync.RWMutex var lock sync.RWMutex 

方式二：使用Go提供的 sync.Map var map sync.Map

#### 3.4、map的扩容时机

条件一：超过负载

条件二：溢出桶太多

在 Go 中，map 的扩容是由运行时自动处理的，不需要用户手动干预。具体的扩容时机如下：

1. 当 map 中的键值对数量达到当前容量的 7/8（或 87.5%）时，会触发扩容操作。
2. 扩容操作将创建一个更大的哈希表，并重新计算键的哈希值和新的桶位置。
3. 在扩容过程中，会将原有的键值对重新分配到新的哈希表中，因此会涉及一次数据复制的开销。
4. 扩容完成后，新的哈希表取代旧的哈希表，以支持更多的键值对。

### 4、怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？

1. 使用互斥锁（Mutex）：

   - 使用 sync 包中的互斥锁可以确保在任何时刻只有一个 goroutine 可以访问 map。
   - 在读取或修改 map 之前获取锁，在操作完成后释放锁。
   - 这种方法可以确保并发访问的安全性，但也会引入一定的性能开销。

2. 使用读写锁（RWMutex）：

   - 使用 sync 包中的读写锁可以允许多个 goroutine 并发地读取 map，但只有一个 goroutine 可以进行写操作。
   - 在读取 map 时获取读锁，在修改 map 时获取写锁。
   - 对于读多写少的场景，使用读写锁可以提高并发性能。

3. 使用通道（Channel）：

   - 将 map 的读写操作封装成函数，并使用通道作为读写请求的队列。
   - 创建一个专门用于执行 map 操作的 goroutine，通过通道接收读写请求，并按顺序处理这些请求。
   - 通过通道实现的串行化访问方式，可以确保并发访问的安全性。

   除了上述方法外，还可以使用 sync 包中其他的同步原语（如原子操作、条件变量等）来处理对 map 的并发访问。此外，还有一种更简单的方案是避免直接对 map 进行并发访问，而是将 map 操作限定在单个 goroutine 中，通过通道或其他数据结构将需要进行并发访问的操作发送给该 goroutine 处理，从而避免了直接的并发访问。

   不同处理方式的区别主要在于实现的复杂性和性能开销。使用互斥锁能够确保并发访问的安全性，但会引入一定的性能开销；使用读写锁可以提高读取性能，但写入仍然需要串行化；使用通道可以避免竞争条件，但可能引入阻塞等待的开销。选择合适的处理方式需根据具体场景和需求进行权衡。

### 5、哪些类型不能作为map的key

**在golang规范中，可比较的类型都可以作为map key；**

**不能作为map key 的类型包括：**

- slices
- maps
- functions

### 6、map的底层数据结构是什么样的？

```go
// Map contains Type fields specific to maps.
type Map struct {
    Key  *Type // Key type
    Elem *Type // Val (elem) type

    Bucket *Type // internal struct type representing a hash bucket
    Hmap   *Type // internal struct type representing the Hmap (map header object)
    Hiter  *Type // internal struct type representing hash iterator state
}
```

前两个字段分别为 key value, 由于 go map 支持多种数据类型, go 会在编译期推断其具体的数据类型, Bucket 是**哈希桶**, Hmap 表征了 map 底层使用的 **HashTable** 的元信息, 如当前 HashTable 中含有的元素数据、桶指针等, Hiter 是用于遍历 go map 的数据结构

### 7、哈希冲突？

#### 1、什么是哈希冲突？

哈希冲突是指在使用哈希表（Hash Table）时，**两个或多个不同的键（Key）经过哈希函数计算后，得到相同的哈希值**，从而导致它们被映射到哈希表的同一个位置（桶/槽位）。

#### 2、**为什么会出现哈希冲突？**

1. **哈希函数的输出范围有限**
   - 哈希函数通常将任意长度的输入映射到一个固定范围的整数值（如 32 位或 64 位整数）。
   - 由于输出范围有限，而可能的输入是无限的（例如所有可能的字符串），因此必然会出现不同的键映射到相同哈希值的情况。
2. **鸽巢原理（Pigeonhole Principle）**
   - 如果哈希表的桶数量（N*N*）小于可能的键数量（M*M*），则必然有至少两个键会落在同一个桶中。



#### 3、**哈希冲突的影响**

- 如果哈希冲突过多，会导致：
  - **查找、插入、删除操作的性能下降**（从理想的 O(1)*O*(1) 退化成 O(n)*O*(*n*)）。
  - **哈希表空间利用率降低**，某些桶可能非常拥挤，而其他桶可能几乎为空。

#### 4、**如何解决哈希冲突？**

**1. 链地址法（Separate Chaining）**

- **原理**：每个哈希表的桶（Bucket）存储一个链表（或动态数组），所有哈希值相同的键值对都存放在同一个链表中。
- **查找方式**：先计算哈希值找到桶，然后在链表中顺序查找。
- **优点**：
  - 实现简单。
  - 可以存储任意数量的冲突键。
- **缺点**：
  - 链表过长时，查找效率会降低（退化成 O(n)*O*(*n*)）。
  - 额外的指针存储开销。
- **应用**：Java `HashMap`、Go `map`（Go 使用数组 + 溢出桶的方式实现链式存储）。

**2. 开放寻址法（Open Addressing）**

- **原理**：如果发生冲突，就按照某种探测方法（如线性探测、二次探测、双重哈希）寻找下一个可用的空槽位。
- **查找方式**：计算哈希值后，如果目标位置已被占用，就继续探测，直到找到空位或匹配的键。
- **优点**：
  - 不需要额外的存储空间（如链表指针）。
  - 缓存友好（数据连续存储）。
- **缺点**：
  - 容易产生聚集（Clustering），导致性能下降。
  - 删除操作较复杂（需要标记为“已删除”而非直接移除）。
- **应用**：Python `dict`、Redis `Hash Table`。

**3. 再哈希（Rehashing）**

- **原理**：当哈希冲突较多时，扩大哈希表容量，并重新计算所有键的哈希值，重新分布。
- **优点**：
  - 减少冲突概率。
- **缺点**：
  - 扩容时性能开销大（需要迁移所有数据）。
- **应用**：大多数动态哈希表（如 Go `map`、Java `HashMap`）都会在负载因子（Load Factor）达到阈值时自动扩容。

**4. 布谷鸟哈希（Cuckoo Hashing）**

- **原理**：使用多个哈希函数，每个键可以有多个候选位置。如果冲突，就把旧键踢到它的另一个候选位置，直到所有键都能存放或达到最大尝试次数（此时需要扩容）。
- **优点**：
  - 最坏情况下查找时间仍为 O(1)*O*(1)。
- **缺点**：
  - 实现复杂。
  - 插入操作可能较慢（可能需要多次踢出键）。
- **应用**：某些高性能哈希表实现（如 Rust 的 `hashbrown` 库）。

#### **5、Go 语言中的哈希冲突处理**

Go 的 `map` 采用 **链地址法 + 渐进式扩容** 的方式：

1. **每个桶存储 8 个键值对**，如果冲突超过 8 个，则使用 **溢出桶（Overflow Bucket）** 链式存储。
2. **当哈希表负载过高时**，会触发扩容（可能是双倍扩容或等量扩容整理溢出桶）。
3. **扩容是渐进式的**，不会一次性迁移所有数据，而是在后续操作中逐步完成。

#### **总结**

| 方法           | 原理                      | 优点                 | 缺点               | 适用场景                 |
| :------------- | :------------------------ | :------------------- | :----------------- | :----------------------- |
| **链地址法**   | 冲突的键存放在链表/溢出桶 | 实现简单，存储灵活   | 链表过长时性能下降 | Go `map`、Java `HashMap` |
| **开放寻址法** | 冲突时探测下一个空位      | 内存紧凑，缓存友好   | 容易聚集，删除复杂 | Python `dict`、Redis     |
| **再哈希**     | 扩容后重新分布键          | 减少冲突             | 扩容开销大         | 大多数动态哈希表         |
| **布谷鸟哈希** | 多个哈希函数，踢出冲突键  | 最坏 O(1)*O*(1) 查找 | 实现复杂           | 高性能哈希表             |

哈希冲突是哈希表设计中必须解决的问题，不同的方法各有优劣，实际实现中可能会结合多种策略（如 Go 的链地址法 + 渐进式扩容）。

### 8、sync.Map底层结构？

sync.Map 主类中包含以下核心字段：

（1）read：无锁化的**只读 map**，实际类型为 readOnly

（2）dirty：加锁处理的**读写 map**；

（3）misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换；

（4）mu：一把**互斥锁**，实现 dirty 和 misses 的并发管理.

![](Tartarnus/image/go基础.images/v2-b639f56e56b355507d16932e63f55e19_720w.webp)

### **9、Rehashing后，hash如何找到键值？**

在哈希表进行 Rehashing 后，即扩容或缩容后，哈希表中的键值对会重新分配到新的哈希桶中。为了找到键对应的值，需要经过以下步骤：

1. 首先，通过哈希函数计算键的哈希值。
2. 根据新的哈希表大小，**对哈希值取模，得到新的桶索引**。
3. 在新的哈希表中，根据桶索引找到对应的桶。
4. 在找到的桶中，遍历桶内的链表或使用其他解决哈希冲突的方法（如开放地址法、二次探查等）来寻找具体的键值对。

由于 Rehashing 后，键值对的位置会发生变化，因此必须通过重新计算哈希值和桶索引的方式来找到键对应的值。所以，找到键值的过程与普通的哈希表查询相同，只是要根据新的哈希结构进行计算和查找。

需要注意的是，在 Rehashing 过程中，哈希表可能处于一个中间状态，既包含部分原始桶中的键值对，又包含一部分新桶中的键值对。这种情况下，需要根据哈希表的实现策略来处理，并将查询操作适配到新的哈希表结构上。

### 10、go中map的扩容机制？

在 Go 中，map 是一种内置的哈希表数据结构，用于存储键值对。当 map 中的元素数量达到一定阈值时，会触发扩容操作。

map 的扩容机制如下：

1. 当 map 中的元素数量超过了当前哈希桶数量的 6.5 倍（即负载因子超过 6.5），会触发扩容。负载因子是指元素数量与哈希桶数量的比值。
2. 扩容涉及两个因素：新的哈希桶数量和重新计算元素在新桶中位置的哈希值。
3. 新的哈希桶数量是原来的两倍，并向上取最近的 2 的幂次方。例如，如果原来的哈希桶数量为 8，则新的哈希桶数量为 16。
4. 扩容过程中，原来的所有键值对会被重新分配到新的哈希桶中。为了实现这个目标，会为每个新桶创建一个链表，然后将元素按照新的哈希值分布到对应的桶中。
5. 在扩容过程中，其他协程可以继续访问原有的 map，但是会使用读锁进行保护，因此读操作不会阻塞。但写操作需要获取写锁，可能会被阻塞。

需要注意的是，由于扩容涉及重新计算哈希值和元素的重新分布，因此在扩容期间对 map 进行写操作可能会导致性能下降。因此，在并发场景下，建议使用 sync.Map 或采用其他并发安全的数据结构来代替普通的 map。

总结起来，Go 中的 map 会在元素数量超过负载因子阈值时触发扩容。扩容会创建新的哈希桶，将元素重新分布到新桶中，并更新哈希值。在扩容期间，读操作可以继续进行，但写操作可能会被阻塞。因此，在并发场景下需要注意扩容对性能的影响。

#### 10.1、go中map扩容的阈值和扩容倍数是多少？

在 Go 中，map 的扩容阈值和扩容倍数是动态确定的，具体取决于当前 map 的大小。

1. 扩容阈值：当 map 中元素数量超过当前哈希桶数量的 6.5 倍时，会触发扩容。也就是说，负载因子（元素数量与哈希桶数量的比值）超过了 6.5，就会进行扩容。
2. 扩容倍数：每次扩容时，新的哈希桶数量是原有数量的两倍。例如，如果当前 map 的哈希桶数量为 8，那么扩容后的哈希桶数量将是 16。

需要注意的是，扩容操作是自动进行的，并且由 Go 运行时系统负责管理。我们无法手动控制或干预扩容的阈值和倍数。

此外，可以通过在代码中使用 `map` 的 `len` 函数获取当前 map 的元素数量，以及 `cap` 函数获取当前 map 的哈希桶数量。这些函数可以用于了解 map 的填充情况和哈希桶数量，从而对 map 的性能进行评估和优化。

总结起来，在 Go 中，map 的扩容阈值是当前哈希桶数量的 6.5 倍，扩容倍数是原有数量的两倍。具体的阈值和倍数是由 Go 运行时系统动态确定和管理的，无法手动控制。

## 三**、context相关**

### **1、context 结构是什么样的？context 使用场景和用途？**

 Go 中，`context` 是一个标准库（`context` 包）中定义的用于传递上下文信息的结构。

`context.Context` 结构是一个接口类型，定义了管理请求的上下文信息的方法，它具有以下主要方法：

- `Deadline()`：返回上下文的截止时间（即取消时间），超过该时间后应该取消上下文。
- `Done()`：返回一个通道，当上下文被取消或超时时，该通道将被关闭。
- `Err()`：返回导致上下文被取消的错误原因。
- `Value(key interface{})`：返回与给定键相关联的值。

`context.Background()` 和 `context.TODO()` 是两个常用的函数，用于创建初始的上下文对象。

`context` 的主要用途是在多个 goroutine 之间传递请求相关的上下文信息，例如取消信号、超时控制、请求跟踪和日志记录等。通过将上下文作为参数传递，在不同的 goroutine 中可以共享相同的上下文，并根据上下文的状态进行相应的操作。

**常见的 `context` 使用场景包括：**

1. 请求传递：将上下文从一个处理器传递到另一个处理器，用于在整个请求处理链中传递请求信息、取消信号以及控制超时。
2. 取消机制：使用上下文来实现取消操作，当需要提前结束某个操作时，可以调用 `context` 的 `cancel()` 方法取消相应的 goroutine。
3. 超时控制：使用上下文和 `context.WithTimeout()` 或 `context.WithDeadline()` 可以设定超时时间，当超过设定时间时自动取消上下文。
4. 请求跟踪和日志记录：可以将请求相关的跟踪 ID、日志记录器等信息存储在上下文中，以便在多个处理器中共享并进行日志记录。

通过使用 `context`，我们可以更好地管理和控制并发操作，提供了一种优雅的方式来处理传递和取消上下文的需求。

### 2、有几种类型的context？

1、**context.Background()**

这个函数返回一个空 context。这只能用于高等级（在 main 或顶级请求处理中）。这能用于派生我们稍后谈及的其他 context 。

2、**context.TODO()**

这个函数也是创建一个空 context。也只能用于高等级或当您不确定使用什么 context，或函数以后会更新以便接收一个 context 。这意味您（或维护者）计划将来要添加 context 到函数。

3、**context.WithValue(parent Context, key, val interface{}) (ctx Context, cancel CancelFunc)**

此函数接收 context 并返回派生 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，而是函数应接收签名中的那些值，使其显式化。

4、**context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)**

这是它开始变得有趣的地方。此函数创建从传入的父 context 派生的新 context。父 context 可以是后台 context 或传递给函数的 context。

返回派生 context 和取消函数。只有创建它的函数才能调用取消函数来取消此 context。如果您愿意，可以传递取消函数，但是，强烈建议不要这样做。这可能导致取消函数的调用者没有意识到取消 context 的下游影响。可能存在源自此的其他 context，这可能导致程序以意外的方式运行。简而言之，永远不要传递取消函数。

5、**context.WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc)**

此函数返回其父项的派生 context，当截止日期超过或取消函数被调用时，该 context 将被取消。例如，您可以创建一个将在以后的某个时间自动取消的 context，并在子函数中传递它。当因为截止日期耗尽而取消该 context 时，获此 context 的所有函数都会收到通知去停止运行并返回。

```text
ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))
```

6、**context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)**

此函数类似于 context.WithDeadline。不同之处在于它将持续时间作为参数输入而不是时间对象。此函数返回派生 context，如果调用取消函数或超出超时持续时间，则会取消该派生 context。

```text
ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)
```

## **四、channel相关**

### **1、channel 是否线程安全？**

在 Go 中，通道（channel）是**线程安全**的。可以在多个 goroutine 之间安全地读取和写入通道，而无需额外的锁或同步机制。这是因为 Go 的通道内部实现了同步和互斥机制，确保了并发访问的安全性。

#### 1.1、channel的线程安全是如何实现的？

在 Go 中，通道的线程安全是通过内置的同步机制来实现的。Go 语言的通道使用了以下技术来保证线程安全：

1. **互斥锁**（Mutex）：通道中的读取和写入操作都涉及到共享状态的访问，但这些操作是互斥的，只能有一个 goroutine 在任何给定时刻进行读取或写入。因此，通道内部使用互斥锁来确保在同一时间内只有一个 goroutine 能够访问通道的底层数据结构。
2. **条件变量**（Condition Variable）：通道的阻塞和解除阻塞操作是通过条件变量来实现的。当一个 goroutine 尝试向满通道发送数据时，它会被阻塞，并且该 goroutine 将会被加入到等待接收数据的队列中。只有当另一个 goroutine 从通道中读取数据或者通道为空时，条件变量才会唤醒被阻塞的 goroutine。
3. **内存屏障**（Memory Barrier）：Go 运行时使用内存屏障来确保通道中数据的可见性。内存屏障是一种硬件或软件层面的机制，用于处理多核或多线程环境中的并发访问。在通道中，内存屏障能够保证数据在发送和接收操作之间的一致性，防止出现数据竞争或不一致的问题。

通过这些同步机制的组合，Go 的通道能够提供线程安全的并发访问。无论是发送操作还是接收操作，都会按照先到先服务（FIFO）的顺序进行，并且只有在满足特定条件时才会解除阻塞。这种设计保证了数据的有序性和一致性，避免了常见的并发问题，如数据竞争和死锁。

总结：Go 语言的通道利用互斥锁、条件变量和内存屏障等同步机制来实现线程安全。通过这些机制的协同作用，通道能够保证数据的有序访问和一致性，在多个 goroutine 之间提供安全的并发通信和共享数据的方式。

### 2、channel的底层实现？

**1、缓存区指针（循环数组）**

指向缓存区，缓存区创建channel时指定大小，缓存区满则阻塞写操作

**2、读写等待队列**

用于保存读chan和写chan数据被阻塞的goroutine队列： sendq 和 recvq

**3、读写等待队列索引**

用来记录此循环数组当前发送或接收数据的下标值

**4、互斥锁（Mutex）**

通道中的读取和写入操作都涉及到共享状态的访问，但这些操作是互斥的，只能有一个 goroutine 在任何给定时刻进行读取或写入。因此，通道内部使用互斥锁来确保在同一时间内只有一个 goroutine 能够访问通道的底层数据结构。

### 3、无缓冲channel和有缓冲channel的区别

最大的区别是一个是**同步**的，一个是非同步的

无缓冲：例如 chan<-1，不仅是向通道放入1，而是要一直等有别的goroutine接收这个参数，那么 chan<-1 才会继续走下去，否则会一直阻塞着。（即如果在一个协程里执行放入取出操作的话会一直阻塞，需要在不同的协程执行）
有缓冲：例如 chan<-1 ，执行后不会阻塞，因为缓冲大小为1；只有当放第二个值且第一个值还没被人拿走，才会阻塞。

### 4、channel有几种模式？

**channel有3种模式**:写操作模式(单向通道)、读操作模式（单向通道)、读写操作模式(双向通道)

![在这里插入图片描述](image/e59ac0b63e204306951e2c4f5593dab4.png)

### 5、channel有几种状态？

**channel有3种状态**:未初始化、正常、关闭

![在这里插入图片描述](image/d1f842e1e1b34e549053cf2e52efc95a.png)

**注意点:**

1.一个channel不能多次关闭,会导致painc

2.如果多个goroutine都监听同一个channel，那么 channel 上的数据都可能随机被某一个goroutine取走进行消费

3.如果多个goroutine监听同一个channel，如果这个channel被关闭，则所有goroutine都能收到退出信号





## **五、goroutine相关**

### 1、什么是 GMP？（必问）

答：G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在 GMP 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。M 会从 P 的队列中取一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会从其他的 MP 组合偷取一个可执行的 G 来执行，当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。

1. G（Goroutine）：Goroutine 是 Go 语言并发模型的基本执行单元。它可以看作是比线程更轻量级的协程，用于并发执行任务。在 Go 程序中，我们可以创建成千上万个 goroutine 来处理并发任务，而每个 goroutine 都会分配一些栈空间供其运行使用。**（简述：Goroutine）**
2. M（Machine）：M 代表了 Go 语言运行时系统中的逻辑处理器或机器。在 Go 程序中，M 负责管理和调度 goroutine 的执行。一个 M 可以绑定到一个操作系统的线程上，也就是 P（Processor）所指的含义。**（简述：线程）**
3. P（Processor）：P 代表了 Go 语言调度器所使用的逻辑处理器。每个 P 都绑定到一个操作系统的线程上，并负责调度和管理一组 goroutine。通过 P，调度器能够在多个 M 上均匀地分配 goroutine 来实现并发执行。**（简述：逻辑处理器）**

#### **1.1、数量问题？**

关于 G,P,M 的个数问题，G 的个数理论上是无限制的，但是受内存限制，**P =M（默认，具体可以通过GOMAXPROCS设置）**，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。

- **建议**：
  - **CPU 密集型任务**：保持 `P ≈ CPU 核心数`（避免过多上下文切换）。
  - **I/O 密集型任务**：可适当增加 `P`（如 `核心数 × 2`），但需结合监控（如 `pprof`）验证效果。

#### 1.2、调度器的设计策略

复用线程：避免频繁的创建、销毁线程，而是对线程的复用。

**1）work stealing 机制**

 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。

**2）hand off 机制**

 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。

全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

### **3、抢占式调度是如何抢占的？**

**1、基于协作式抢占**

**2、基于信号量抢占**

就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。**基于经典的时间片(10ms)算法**，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。

**基于时间片的抢占式调度**有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。

### 4、怎么控制并发数？

控制并发数是指限制同时执行的并发操作数量，可以通过以下几种方式进行控制：

1. **信号量**（Semaphore）：信号量是一种计数器，用于记录可用的资源数量。你可以创建一个具有指定数量的信号量，并在并发操作开始之前获取信号量，执行完毕后释放信号量。通过控制信号量的数量，可以限制并发操作的数量。
2. **互斥锁**（Mutex）：互斥锁是一种同步原语，它可以用于限制同时只有一个 goroutine 可以进入临界区。通过在并发操作的开头使用互斥锁进行加锁，保证同一时间只有一个操作可以执行，从而实现对并发数的控制。
3. **WaitGroup**：WaitGroup 是 Go 语言提供的一种等待机制，它可以用于等待一组并发操作完成。你可以使用 Add 方法增加等待的数量，每个并发操作执行完毕后使用 Done 方法减少等待数量，最后通过 Wait 方法阻塞主线程，直到所有并发操作完成。
4. **Channel**：通过使用带缓冲区的通道，可以在进行并发操作时进行控制。你可以创建一个带有限定容量的通道，并在执行并发操作之前往通道发送值。通道的容量限制了同时进行并发操作的数量，当通道已满时，其他并发操作会被阻塞。
5. **并发安全的数据结构**：某些并发安全的数据结构（如 sync.Map）或库（如限制并发访问的连接池）内部实现了对并发数的控制。通过使用这些数据结构或库，你可以间接地控制对共享资源的并发访问数量。
6. **ants.Pool**

### 5、goroutine底层是怎么实现的

在 Go 语言中，goroutine 是一种轻量级的用户态线程，由 Go 运行时负责调度和管理。它与传统的操作系统线程（kernel threads）有所不同，具有以下特点：

1. Goroutine 的调度器：Go 运行时拥有自己的调度器，负责将 goroutine 映射到操作系统线程上进行并发执行。调度器会在 goroutine 阻塞、发生系统调用等情况下，将当前的 goroutine 暂停，然后使用其他可用的线程执行其他就绪状态的 goroutine。
2. 用户态线程：和传统的操作系统线程相比，goroutine 是在用户态运行的线程，不依赖于操作系统的线程机制。这使得创建和销毁 goroutine 可以更加轻量和高效，因为不需要频繁地涉及内核态和用户态之间的切换。
3. 栈的大小：每个 goroutine 具有固定大小的栈空间，通常默认为 2KB。相较于传统操作系统线程所需的固定栈大小，goroutine 的栈是动态增长和缩减的，可以根据需要进行动态调整。这使得可以同时创建大量的 goroutine，而不会占用过多的内存。
4. 协作式调度：Goroutine 采用协作式调度方式，即在代码逻辑的特定点进行主动让出，让其他可执行的 goroutine 有机会运行。这种方式避免了传统线程的抢占式调度带来的开销和复杂性，并且可以有效地控制资源的共享和同步。
5. 通信机制：Goroutine 之间通过通信来共享数据，在实现上使用了轻量级的管道（channel）机制。通过 channel，不同的 goroutine 可以安全地发送和接收数据，从而实现了高效的并发编程。

总的来说，goroutine 的实现基于 **Go 运行时的调度器**和**用户态线程模型**，通过**协作式调度**、**动态栈管理**和**管道**等特性，提供了高效、轻量级、简单易用的并发编程方式。这使得开发人员能够轻松地创建大量的 goroutine，并充分利用多核处理器进行并发执行，同时避免了传统线程所带来的复杂性和性能损失。

### **6、goroutine切换的时机**

1、select操作阻塞时
2、io阻塞
3、阻塞在channel
4、程序员显示编码操作
5、等待锁
6、程序调用

### 7、goroutine 什么时候发生阻塞

- channel 在等待网络请求或者数据操作的IO返回的时候会发生阻塞
- 发生一次系统调用等待返回结果的时候
- goroutine进行sleep操作的时候

### **8、sysmon**

Go Runtime 在启动程序的时候，会创建一个独立的 `M` 作为监控线程，称为 `sysmon`，它是一个系统级的 `daemon` 线程。这个`sysmon` 独立于 GPM 之外，也就是说不需要P就可以运行，因此官方工具 `go tool trace` 是无法追踪分析到此线程（[源码](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.15.6%2Fsrc%2Fruntime%2Fproc.go%23L4639-L4760)）。

**作用：**

- **网络轮询器（netpoller）**：将阻塞的Socket IO转为异步事件（epoll），避免M阻塞。
- **抢占调度**：监控运行超过10ms的G，发送异步抢占信号（基于栈扩张或协作式抢占）。
- **GC触发**：强制回收长时间未处理的内存。
- **阻塞时把P和M解绑：**由应用程序创建的计时器（timers）。sysmon查看应该在运行但仍在等待的计时器。在这种情况下，Go将查看空闲的M和P列表以尽快运行它们

## 六、锁相关

### 1、除了 mutex 以外还有那些方式安全读写共享变量？

除了使用互斥锁（mutex）之外，还有以下几种方式可以安全地进行读写共享变量：

1. **原子操作**（atomic operations）：Go 语言的 `sync/atomic` 包提供了一组原子操作函数，如 `AddInt64`、`LoadUint32`、`StorePointer` 等。使用原子操作可以直接对共享变量进行原子增减、加载和存储等操作，避免了互斥锁的开销。
2. **读写锁**（read-write lock）：在读多写少的场景下，可以使用读写锁来提高并发性能。Go 语言的 `sync.RWMutex` 类型提供了读写锁的功能。读锁可以同时被多个 goroutine 获取，但写锁只能被一个 goroutine 获取。读写锁适用于多个 goroutine 同时读取共享变量的情况，读操作之间不会产生竞争，从而提高并发性能。
3. **通道**（channel）：通过使用带缓冲区的通道，可以在进行读写操作时进行同步。通过将共享变量放入通道中进行传递，可以确保每次只有一个 goroutine 在读写该变量。这种方式可以避免数据竞争和锁的使用，但仅适用于需要传递值的场景。
4. **原子比较交换**（compare-and-swap）：原子比较交换操作是一种乐观锁机制，通过比较共享变量的当前值和期望值是否相等，并在相等的情况下进行修改，可以实现对变量的原子更新。Go 语言的 `sync/atomic` 包提供了相关的原子比较交换函数，如 `CompareAndSwapInt32`、`CompareAndSwapPointer` 等。
5. **写时复制**（copy-on-write）：写时复制是一种在并发情况下处理共享变量的策略。当一个 goroutine 需要修改共享变量时，会先创建该变量的副本，并在副本上进行修改，而不是直接修改原始变量。这样可以避免多个 goroutine 之间的竞争，提高并发性能。写时复制通常用于不经常修改但频繁读取的大型数据结构，如字典、列表等。

#### **1.1、原子操作与互斥锁的区别**

原子操作（atomic operations）和互斥锁（mutex）是并发编程中常用的两种保证对共享变量安全访问的机制，它们有以下几点不同之处：

1. 机制：原子操作是一种底层的硬件级别的指令，用于在单个操作中完成对共享变量的读取、修改和存储，保证这个操作是不可分割的。而互斥锁是一种高级的同步原语，通过对共享资源进行加锁和解锁，控制多个 goroutine 对共享变量的访问顺序，确保一次只有一个 goroutine 可以访问。
2. 开销：原子操作通常比互斥锁的开销更小。在原子操作中，不需要进行上下文的切换或者系统调用，因此可以获得更好的性能。而互斥锁会涉及到线程的切换、上下文的保存和恢复等额外开销，因此在频繁竞争的情况下可能会导致较大的性能损失。
3. 功能：原子操作只能完成基本的读取和修改操作，如增减、加载和存储等。而互斥锁提供了更灵活的功能，可以支持任意代码段的临界区保护，即一次只允许一个 goroutine 进入临界区。
4. 使用场景：原子操作适用于对单个共享变量的简单操作，如计数器的自增/自减。而互斥锁适用于对复杂数据结构或临界区的保护，可以确保在临界区中的操作是原子的。

## **七、GC相关**

### 1、go gc 是怎么实现的？（必问）

Go 语言的垃圾回收（Garbage Collection，简称 GC）是通过自动内存管理实现的。Go 的 GC 实现基于三色标记清除算法（Tricolor Mark and Sweep Algorithm）和写屏障技术（Write Barrier），下面是大致的工作流程：

1. 标记阶段（Marking Phase）：GC 首先从根对象（如全局变量、栈上的引用等）开始，通过追踪可达性，将所有活跃的对象标记为存活对象。在标记过程中使用了三个颜色标记法：白色（未访问）、灰色（已访问但未递归处理子对象）、黑色（已访问且已递归处理子对象）。
2. 写屏障（Write Barrier）：Go 的 GC 引入了写屏障技术来追踪对指针的修改。**当程序中的代码对指针进行写操作时，会触发写屏障，将被修改对象标记为灰色，以确保这个对象及其子对象在标记阶段能够被正确追踪到**。
3. 清除阶段（Sweeping Phase）：在标记阶段完成后，GC 将扫描整个堆，回收所有未被标记的对象。这些未被标记的对象被认为是不可达的，并且可以被安全地释放内存。
4. 内存整理（Memory Compaction）：GC 在清除阶段之后可能还会进行内存整理操作，将存活对象的内存整理到一起，以减少内存碎片化。内存整理过程可能涉及对对象的移动和调整引用关系。

#### 1.1、什么是三色标记法？会回收哪些对象？

三色标记法是一种垃圾回收算法，用于标记和回收不再被程序使用的内存对象。在三色标记法中，将内存对象分为三种颜色：白色、灰色和黑色。

1. 白色对象：表示未被访问或未被标记的对象。这些对象可能是新分配的、被程序临时引用的或已经被标记但尚未被访问到的对象。
2. 灰色对象：表示已经被标记但尚未被完全访问的对象。灰色对象通常是由于存在对其他未被访问对象的引用而导致的。
3. 黑色对象：表示已经被标记且已经被完全访问的对象。黑色对象是确定会被程序继续使用的对象。

三色标记法的工作过程如下：

1. 初始时，将所有对象标记为白色。
2. 从根节点（如全局变量、栈上的引用等）开始，递归或迭代地遍历所有可达对象，并将其标记为灰色。
3. 遍历灰色对象的引用，如果引用指向的对象为白色，则将其标记为灰色。
4. 继续遍历灰色对象，直到没有灰色对象为止。
5. 最后，所有未被标记为黑色的**白色对象即为无用的对象，可以被回收**。

通过三色标记法，垃圾回收器可以确定哪些对象是可达的，哪些对象是无用的，从而能够安全地回收未被使用的内存资源。值得注意的是，灰色对象的存在是为了处理对象间的相互引用情况，确保回收器能够正确标记对象之间的关系，避免误判和泄漏。

### 2、GC 中 stw 时机，各个阶段是如何解决的？

在 Go 的垃圾回收（Garbage Collection，简称 GC）过程中，STW（Stop-The-World）指的是暂停程序的执行，以便进行垃圾回收操作。然而，在 Go 1.13 及之后的版本中，GC 的 STW 时间已经被显著降低，并且只会在必要的情况下才被触发。

下面是各个阶段中如何解决 STW 的问题：

1. **标记阶段（Marking Phase）**：标记阶段是并发执行的，不会导致长时间的 STW。Go 在标记阶段中使用 write barrier 技术，通过跟踪对指针的写操作，确保可达对象被正确地标记为活跃对象，并且可以同时进行程序的执行。这种并发标记的方式减少了 STW 的时间和影响。
2. **根扫描（Root Scanning）**：GC 使用 write barrier 追踪对根对象的修改，并且并发进行根扫描操作，以识别程序的根对象。这样可以在减少 STW 时间的同时，确保所有的根对象被检测到。
3. **存活对象寻找（Finding Live Objects）**：在并发标记完成后，GC 需要进行额外的工作来找到所有存活的对象。这个过程也是并发执行的，与程序的执行同时进行。GC 使用了并发算法来在不停顿程序的情况下找到存活对象，以减少 STW 时间。
4. **清除阶段（Sweeping Phase）**：在并发标记和存活对象寻找完成后，GC 进入清除阶段。清除阶段也是并发执行的，GC 会扫描整个堆，回收所有未标记的对象，并释放它们占用的内存空间。这个过程也不会导致 STW。

需要注意的是，尽管 Go 的 GC 实现采取了并发的策略来减少 STW 时间，但在某些情况下，仍然可能会发生短暂的 STW，例如在堆增长时或者进行某些特定的 GC 操作时。但是，在大多数情况下，GC 的 STW 时间已经大大减少，并且对程序的执行影响较小。

### 3、GC 的触发时机？

**系统触发**

1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。

2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。

3）gcTriggerCycle：如果没有开启 GC，则启动 GC。

**主动触发**

1）手动触发的 runtime.GC 方法。

### 4、GC如何调优？

1、控制内存分配速度，限制goroutine数量，提高赋值器mutator的cpu使用率（降低GC的CPU使用率）

2、少使用 + string

3、slice提前分配足够内存减少扩容带来的拷贝

4、避免map key对象过多，导致扫描时间增加

5、变量复用，减少对象分配

6、增大GOGC值，降低GC运行频率

### 5、简述Go三色标记法的核心步骤，并解释为什么需要**写屏障（Write Barrier）**？

1. **三色标记步骤**：
   - **阶段1（STW）**：暂停程序，扫描所有**根对象**（栈、全局变量等），标记为灰色。
   - **阶段2（并发标记）**：遍历灰色对象，将其引用的子对象标记为灰色，自身转为黑色。
   - **阶段3（STW）**：二次暂停，重新扫描栈，处理并发期间新增的引用。
   - **阶段4（清除）**：回收所有白色对象。
2. **写屏障的必要性**：
   - **问题场景**：若用户程序在并发标记阶段修改指针（如`A.next = B`且B为白色），可能导致活跃对象被误回收。
   - **解决方案**：Go使用**混合写屏障**（Hybrid Write Barrier），在指针修改时强制将目标对象（B）标记为灰色。

## **八、内存相关**

### 1、什么情况下内存会泄露？怎么定位排查内存泄漏问题？

答：go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一只处于阻塞状态，不能被 GC。

**内存泄露有下面一些情况**

1）如果 **goroutine 在执行时被阻塞**而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。

2）互斥锁未释放或者造成**死锁**会造成内存泄漏

3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。

4）**字符串的截取**引发临时性的内存泄漏

5）**切片截取**引起子切片内存泄漏

6）函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。

**排查方式：**

1、可以使用 pprof 包和相关的命令行工具来收集和分析程序的内存使用情况。

2、内存监控和日志记录：通过记录程序的内存使用情况和相关日志信息，可以帮助定位内存泄漏的位置。例如，记录内存分配和释放的次数、缓存大小的变化等。

3、单元测试和压力测试：编写相应的单元测试和压力测试来模拟不同场景下的内存使用情况，并观察内存是否正常释放。



### 2、知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）

答：1)本该分配到栈上的变量，跑到了堆上，这就导致了内存逃逸。2)栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。3)变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。

**内存逃逸的情况如下：**

1）方法内返回局部变量指针。

2）向 channel 发送指针数据。

3）在闭包中引用包外的值。

4）在 slice 或 map 中存储指针。

5）切片（扩容后）长度太大。

6）在 interface 类型上调用方法。

#### 2.1、go的逃逸分析是怎么分析的？

**1. 编译器逃逸分析基础**

Go编译器在编译阶段会分析变量的生命周期，决定变量分配在**栈**还是**堆**：

- **栈分配**：变量生命周期仅限于函数内部，函数返回后自动释放。
- **堆分配**（逃逸）：变量可能被函数外部引用，需延长生命周期至GC回收。

**2. 判断内存逃逸的实战方法**

**(1) 使用`go build`命令分析**

```bash
go build -gcflags="-m -l" main.go
```

- `-m`：打印逃逸分析结果
- `-l`：禁用内联优化（避免干扰分析）

### 3、请简述 Go 是如何分配内存的？

1. 栈（Stack）：栈是用于管理函数调用和局部变量的一种数据结构。每当一个函数被调用时，栈会为该函数分配一块内存空间，其中包含函数的参数、返回值以及局部变量等。当函数执行完毕后，栈会自动释放该内存空间。栈的分配和释放都是非常快速的，因此适合用于存储较小且生命周期短暂的对象。
2. 堆（Heap）：堆是用于动态分配内存的区域，存储对象的生命周期比栈更长。在堆上分配的内存需要手动释放，否则就会发生内存泄漏。Go 语言的垃圾回收机制（Garbage Collection）负责自动管理堆上的内存。通过使用算法（例如标记-清除算法），垃圾回收器能够识别不再需要的对象，并释放其占用的内存空间。Go 的垃圾回收器会根据堆的大小和对象的分配情况来自动触发垃圾回收。
3. 内存分配器（Memory Allocator）：Go 语言有自己的内存分配器，负责从堆上分配对象所需的内存空间。Go 的内存分配器使用了多个 goroutine（轻量级线程）来同时分配内存，以提高分配效率。内存分配器还会根据对象的大小选择不同的分配策略，例如小对象直接在堆上分配，而大对象则使用指针引用。此外，内存分配器还会重复使用已经释放的内存空间，以减少系统调用的开销。

#### 3.1、内存分配的多级结构

##### 1. mspan

`mspan` 是内存管理的基本单元，是一段连续的 8KB 或更大的内存页（称为 page）。每个 `mspan` 按照固定大小划分成小块，用于分配特定大小的对象。

##### 2. mcache

`mcache` 是每个 **P（Processor）**本地的小对象缓存，无需加锁即可访问。每个 `mcache` 包含一组 `mspan`，用于小对象（<=32KB）的快速分配。

##### 3. mcentral

`mcentral` 是中心缓存，服务于所有 P。当 `mcache` 中的 `mspan` 用完时，会从 `mcentral` 申请新的 `mspan`。

##### 4. mheap

`mheap` 是堆内存的管理者，负责向操作系统申请内存。它管理着所有的 `mspan`，当 `mcentral` 没有可用的 `mspan` 时，会向 `mheap` 申请，当堆内存不足时会向操作系统申请。

#### 3.2、内存分配的方式

Go 中的内存分配有两种方式：**大分配**和**小分配**。大分配是指申请的内存区域大于等于32KB，小分配是指申请的内存区域小于32KB。通常情况下，小分配使用的是内部数据结构 mcache，而大分配则是使用内部的 mheap。

#### 3.3、内存分配流程

**3.1 小对象分配（<32KB）**

1. 确定对象大小级别（size class）
2. 从当前 P 的 `mcache` 中获取对应 size class 的 `mspan`
3. 如果 `mspan` 有空闲位置，直接分配
4. 如果 `mspan` 已满，从 `mcentral` 获取新的 `mspan`
5. 如果 `mcentral` 也没有，向 `mheap` 申请新的 `mspan`
6. 如果 `mheap` 也没有足够内存，向操作系统申请新的内存页

**3.2 大对象分配（>=32KB）**

大对象直接从 `mheap` 分配，不经过 `mcache` 和 `mcentral`。

#### 3.4、内存管理

在 Go 中，内存是由 runtime 包中的 mheap 管理的。mheap 具有自动增长和自动收缩的功能。当运行时需要更多的内存时，mheap 会向操作系统请求新的内存，当不再需要内存时，mheap 会将分配的内存归还给操作系统。

### 4、Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？

Channel 是分配在**堆上**的。Channel 是一种引用类型，它内部包含了一些管理和同步通信的数据结构

1. **栈上分配**：栈上主要用于存储局部变量和函数调用相关的数据。这些对象的生命周期是短暂的，随着函数的执行结束，它们会自动释放。栈上的对象分配和释放都非常快速，不需要垃圾回收。
2. **堆上分配**：堆上主要用于存储动态分配的对象，这些对象的生命周期较长或者大小不确定。Go 的垃圾回收器负责管理堆上的内存。以下是一些在堆上分配的对象：
   - 使用 `new()` 或 `make()` 创建的对象，如 `new(T)` 或 `make([]T, length)`。
   - 通过 `return` 语句返回的指针或引用类型对象。
   - 被闭包（closure）引用的变量，因为闭包可能在函数执行完毕后仍然存在。

### 5、介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？

小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。

**小对象**：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。

**大对象**：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。

### 6、内存溢出问题该如何解决

内存溢出（Memory Overflow）指的是程序在申请内存时，超出了系统可用的内存资源限制，导致程序无法正常执行或崩溃的问题。解决内存溢出问题可以考虑以下几个方面：

1. **检查代码中的内存泄漏**：内存泄漏是指程序分配的内存没有被及时释放，导致内存资源不断累积，最终耗尽可用内存。通过检查代码，确保所有分配的内存都被适时释放，避免不必要的内存占用。
2. **优化算法和数据结构**：某些情况下，内存溢出可能是由于算法或数据结构选择不合适导致的。尝试使用更高效的算法和数据结构，减少内存使用量，提高程序性能。
3. **增加可用内存空间**：如果内存溢出是由于系统可用内存资源不足导致的，可以考虑增加可用内存的方式来解决。例如，增加服务器的物理内存大小，或者调整应用程序的内存限制参数。
4. **分批处理大数据量**：如果程序处理大量数据时导致内存溢出，可以考虑将数据分批加载或处理，避免一次性加载过多数据导致内存不足。可以采用分页、流式处理等方法，减少内存压力。
5. **优化资源使用**：除了内存之外，程序还可能使用其他资源，如文件句柄、数据库连接等。确保及时释放这些资源，避免资源泄漏和资源耗尽问题。
6. **使用内存管理工具**：使用内存管理工具可以帮助检测和定位内存溢出问题。例如，使用内存分析器来检查内存分配和释放的情况，找出潜在的内存泄漏点。
7. **升级或更新软件版本**：有时候内存溢出问题可能是由软件本身的缺陷引起的。在一些情况下，升级或更新软件到最新版本可能修复了这些问题。

## 九、go-zero相关

## 十、gRPC相关

### 1、什么是gRPC

gRPC是一种高性能、开源的远程过程调用 (RPC) 框架，由Google开发，它建立在HTTP/2（基于传输层安全性协议，TLS）上，并使用Protocol Buffers（简称ProtoBuf）作为接口定义语言。

**特点：**

1. 高性能：采用基于二进制的协议格式，通过HTTP/2提供多路复用、流量控制和头部压缩等功能，从而降低网络和处理开销。
2. 跨平台和跨语言：支持多种编程语言，使得不同系统之间可以方便地进行通信。
3. 支持多种序列化格式：默认使用ProtoBuf作为序列化格式，但也可以选择使用其他序列化格式，如JSON。
4. 提供流式处理能力：可以在单个连接上实现双向流式通信，从而支持服务器端流、客户端流和双向流。
5. 支持拦截器和中间件：可以对请求、响应进行拦截和处理，方便实现认证、日志记录等功能。

2、

## 十一、其他问题

### 1、Go 多返回值怎么实现的？

答：Go 传参和返回值是通过 **FP+offset** 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。

### 2、讲讲 Go 中主协程如何等待其余协程退出?

答：Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。

**啰嗦一句：**循环智能二面，手写代码部分时，三个协程按交替顺序打印数字，最后题目做出来了，问我代码中Add()是什么意思，我回答的不是很清晰，这家公司就没有然后了。Add()表示协程计数，可以一次Add多个，如Add(3),可以多次Add(1);然后每个子协程必须调用done（）,这样才能保证所有子协程结束，主协程才能结束。

### 3、Go 语言中不同的类型如何比较是否相等？

答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。

### 4、Go 中 init 函数的特征?

答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。

### 5、Go 中 uintptr 和 unsafe.Pointer 的区别？

答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。

